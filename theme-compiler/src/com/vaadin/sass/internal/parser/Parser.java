/* Generated By:JavaCC: Do not edit this line. Parser.java */
package com.vaadin.sass.internal.parser;

import java.io.*;
import java.net.*;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Map;

import org.w3c.css.sac.ConditionFactory;
import org.w3c.css.sac.Condition;
import org.w3c.css.sac.SelectorFactory;
import org.w3c.css.sac.SelectorList;
import org.w3c.css.sac.Selector;
import org.w3c.css.sac.SimpleSelector;
import org.w3c.css.sac.DocumentHandler;
import org.w3c.css.sac.InputSource;
import org.w3c.css.sac.ErrorHandler;
import org.w3c.css.sac.CSSException;
import org.w3c.css.sac.CSSParseException;
import org.w3c.css.sac.Locator;
import org.w3c.css.sac.LexicalUnit;

import org.w3c.flute.parser.selectors.SelectorFactoryImpl;
import org.w3c.flute.parser.selectors.ConditionFactoryImpl;

import org.w3c.flute.util.Encoding;

import com.vaadin.sass.internal.handler.*;

import com.vaadin.sass.internal.tree.*;

/**
 * A CSS2 parser
 *
 * @author Philippe Le Hï¿½garet
 * @version $Revision: 1.15 $
 */
public class Parser implements org.w3c.css.sac.Parser, ParserConstants {

    // replaces all \t, \n, etc with this StringBuffer.
    static final StringBuilder SPACE = new StringBuilder(" ");

    // the document handler for the parser
    protected SCSSDocumentHandlerImpl documentHandler;
    // the error handler for the parser
    protected ErrorHandler errorHandler;
    // the input source for the parser
    protected InputSource source;

    protected ConditionFactory conditionFactory;
    protected SelectorFactory selectorFactory;

    // temporary place holder for pseudo-element ...
    private String pseudoElt;

    /**
     * Creates a new Parser
     */
    public Parser() {
        this((CharStream) null);
    }

    /**
     * @@TODO
     * @exception CSSException Not yet implemented
     */
    public void setLocale(Locale locale) throws CSSException {
        throw new CSSException(CSSException.SAC_NOT_SUPPORTED_ERR);
    }

    /**
     * Set the document handler for this parser
     */
    public void setDocumentHandler(DocumentHandler handler) {
        this.documentHandler = (SCSSDocumentHandlerImpl) handler;
    }

    public void setSelectorFactory(SelectorFactory selectorFactory) {
        this.selectorFactory = selectorFactory;
    }

    public void setConditionFactory(ConditionFactory conditionFactory) {
        this.conditionFactory = conditionFactory;
    }

    /**
     * Set the error handler for this parser
     */
    public void setErrorHandler(ErrorHandler error) {
        this.errorHandler = error;
    }

    /**
     * Main parse methods
     *
     * @param source the source of the style sheet.
     * @exception IOException the source can't be parsed.
     * @exception CSSException the source is not CSS valid.
     */
    public void parseStyleSheet(InputSource source)
            throws CSSException, IOException {
        this.source = source;
        ReInit(getCharStreamWithLurk(source));
        if (selectorFactory == null) {
            selectorFactory = new SelectorFactoryImpl();
        }
        if (conditionFactory == null) {
            conditionFactory = new ConditionFactoryImpl();
        }

        parserUnit();
    }

    /**
     * Convenient method for URIs.
     *
     * @param systemId the fully resolved URI of the style sheet.
     * @exception IOException the source can't be parsed.
     * @exception CSSException the source is not CSS valid.
     */
    public void parseStyleSheet(String systemId)
            throws CSSException, IOException {
        parseStyleSheet(new InputSource(systemId));
    }

    /**
     * This method parses only one rule (style rule or at-rule, except @charset).
     *
     * @param source the source of the rule.
     * @exception IOException the source can't be parsed.
     * @exception CSSException the source is not CSS valid.
     */
    public void parseRule(InputSource source)
            throws CSSException, IOException {
        this.source = source;
        ReInit(getCharStreamWithLurk(source));

        if (selectorFactory == null) {
            selectorFactory = new SelectorFactoryImpl();
        }
        if (conditionFactory == null) {
            conditionFactory = new ConditionFactoryImpl();
        }
        _parseRule();
    }

    /**
     * This method parses a style declaration (including the surrounding curly
     * braces).
     *
     * @param source the source of the style declaration.
     * @exception IOException the source can't be parsed.
     * @exception CSSException the source is not CSS valid.
     */
    public void parseStyleDeclaration(InputSource source)
            throws CSSException, IOException {
        this.source = source;
        ReInit(getCharStreamWithLurk(source));

        if (selectorFactory == null) {
            selectorFactory = new SelectorFactoryImpl();
        }
        if (conditionFactory == null) {
            conditionFactory = new ConditionFactoryImpl();
        }
        _parseDeclarationBlock();
    }

    /**
     * This methods returns "http://www.w3.org/TR/REC-CSS2".
     * @return the string "http://www.w3.org/TR/REC-CSS2".
     */
    public String getParserVersion() {
        return "http://www.w3.org/TR/REC-CSS2";
    }

    /**
     * Parse methods used by DOM Level 2 implementation.
     */
    public void parseImportRule(InputSource source)
            throws CSSException, IOException {
        this.source = source;
        ReInit(getCharStreamWithLurk(source));

        if (selectorFactory == null) {
            selectorFactory = new SelectorFactoryImpl();
        }
        if (conditionFactory == null) {
            conditionFactory = new ConditionFactoryImpl();
        }
        _parseImportRule();
    }

    public void parseMediaRule(InputSource source)
            throws CSSException, IOException {
        this.source = source;
        ReInit(getCharStreamWithLurk(source));

        if (selectorFactory == null) {
            selectorFactory = new SelectorFactoryImpl();
        }
        if (conditionFactory == null) {
            conditionFactory = new ConditionFactoryImpl();
        }
        _parseMediaRule();
    }

    public SelectorList parseSelectors(InputSource source)
            throws CSSException, IOException {
        this.source = source;
        ReInit(getCharStreamWithLurk(source));

        return null;
    }

    public LexicalUnit parsePropertyValue(InputSource source)
            throws CSSException, IOException {
        this.source = source;
        ReInit(getCharStreamWithLurk(source));

        return expr();
    }

    public boolean parsePriority(InputSource source)
            throws CSSException, IOException {
        this.source = source;
        ReInit(getCharStreamWithLurk(source));

        return prio();
    }

    /**
     * Convert the source into a Reader. Used only by DOM Level 2 parser methods.
     */
    private Reader getReader(InputSource source) throws IOException {
        if (source.getCharacterStream() != null) {
            return source.getCharacterStream();
        } else if (source.getByteStream() != null) {
            // My DOM level 2 implementation doesn't use this case.
            if (source.getEncoding() == null) {
                // unknown encoding, use ASCII as default.
                return new InputStreamReader(source.getByteStream(), "ASCII");
            } else {
                return new InputStreamReader(source.getByteStream(),
                                             source.getEncoding());
            }
        } else {
            // systemId
            // @@TODO
            throw new CSSException("not yet implemented");
        }
    }

    /**
     * Convert the source into a CharStream with encoding informations.
     * The encoding can be found in the InputSource or in the CSS document.
     * Since this method marks the reader and make a reset after looking for
     * the charset declaration, you'll find the charset declaration into the
     * stream.  
     */
    private CharStream getCharStreamWithLurk(InputSource source)
            throws CSSException, IOException {
        if (source.getCharacterStream() != null) {
            // all encoding are supposed to be resolved by the user
            // return the reader
            return new Generic_CharStream(source.getCharacterStream(), 1, 1);
        } else if (source.getByteStream() == null) {
            // @@CONTINUE ME. see also getReader() with systemId
            try {
                source.setByteStream(new URL(source.getURI()).openStream());
            } catch (Exception e) {
                try {
                    source.setByteStream(new FileInputStream(source.getURI()));
                } catch (IOException ex) {
                    throw new CSSException("invalid url ?");
                }
            }
        }
        String encoding = "ASCII";
        InputStream input = source.getByteStream();
        char c = ' ';

        if (!input.markSupported()) {
            input = new BufferedInputStream(input);
            source.setByteStream(input);
        }
        input.mark(100);
        c = (char) input.read();

        if (c == '@') {
            // hum, is it a charset ?
            int size   = 100;
            byte[] buf = new byte[size];
            input.read(buf, 0, 7);
            String keyword = new String(buf, 0, 7);
            if (keyword.equals("charset")) {
                // Yes, this is the charset declaration !

                // here I don't use the right declaration : white space are ' '.
                while ((c = (char) input.read()) == ' ') {
                    // find the first quote
                }
                char endChar = c;
                int i = 0;

                if ((endChar != '"') && (endChar != '\u005c'')) {
                    // hum this is not a quote.
                    throw new CSSException("invalid charset declaration");
                }

                while ((c = (char) input.read()) != endChar) {
                    buf[i++] = (byte) c;
                    if (i == size) {
                        byte[] old = buf;
                        buf = new byte[size + 100];
                        System.arraycopy(old, 0, buf, 0, size);
                        size += 100;
                    }
                }
                while ((c = (char) input.read()) == ' ') {
                    // find the next relevant character
                }
                if (c != ';') {
                    // no semi colon at the end ?
                    throw new CSSException("invalid charset declaration: "
                                           + "missing semi colon");
                }
                encoding = new String(buf, 0, i);
                if (source.getEncoding() != null) {
                    // compare the two encoding informations.
                    // For example, I don't accept to have ASCII and after UTF-8.
                    // Is it really good ? That is the question.
                    if (!encoding.equals(source.getEncoding())) {
                        throw new CSSException("invalid encoding information.");
                    }
                }
            } // else no charset declaration available
        }
        // ok set the real encoding of this source.
        source.setEncoding(encoding);
        // set the real reader of this source.
        source.setCharacterStream(new InputStreamReader(source.getByteStream(),
                                             Encoding.getJavaEncoding(encoding)));
        // reset the stream (leave the charset declaration in the stream).
        input.reset();

        return new Generic_CharStream(source.getCharacterStream(), 1, 1);
    }

    private LocatorImpl currentLocator;
    private Locator getLocator() {
        if (currentLocator == null) {
            currentLocator = new LocatorImpl(this);
            return currentLocator;
        }
        return currentLocator.reInit(this);
    }
    private LocatorImpl getLocator(Token save) {
        if (currentLocator == null) {
            currentLocator = new LocatorImpl(this, save);
            return currentLocator;
        }
        return currentLocator.reInit(this, save);
    }

    private void reportError(Locator l, Exception e) {
        if (errorHandler != null) {
            if (e instanceof ParseException) {
                // construct a clean error message.
                ParseException pe = (ParseException) e;
                if (pe.specialConstructor) {
                    StringBuffer errorM = new StringBuffer();
                    if (pe.currentToken != null) {
                        errorM.append("encountered \u005c"")
                            .append(pe.currentToken.next);
                    }
                    errorM.append('"');
                    if (pe.expectedTokenSequences.length != 0) {
                        errorM.append(". Was expecting one of: ");
                        for (int i = 0; i < pe.expectedTokenSequences.length; i++) {
                            for (int j = 0; j < pe.expectedTokenSequences[i].length; j++) {
                                int kind = pe.expectedTokenSequences[i][j];
                                if (kind != S) {
                                    errorM.append(pe.tokenImage[kind]);
                                    errorM.append(' ');
                                }
                            }
                        }
                    }
                    errorHandler.error(new CSSParseException(errorM.toString(),
                                                             l, e));
                } else {
                    errorHandler.error(new CSSParseException(e.getMessage(),
                                                             l, e));
                }
            } else if (e == null) {
                errorHandler.error(new CSSParseException("error", l, null));
            } else {
                errorHandler.error(new CSSParseException(e.getMessage(), l, e));
            }
        }
    }

    private void reportWarningSkipText(Locator l, String text) {
        if (errorHandler != null && text  != null) {
            errorHandler.warning(new CSSParseException("Skipping: " + text, l));
        }
    }

/*
 * The grammar of CSS2
 */

/**
 * The main entry for the parser.
 *
 * @exception ParseException exception during the parse
 */
  final public void parserUnit() throws ParseException {
    try {
          documentHandler.startDocument(source);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHARSET_SYM:
        charset();
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
        case CDO:
        case CDC:
        case ATKEYWORD:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          jj_consume_token(S);
          comments();
          break;
        case CDO:
        case CDC:
        case ATKEYWORD:
          ignoreStatement();
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPORT_SYM:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        importDeclaration();
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CDO:
          case CDC:
          case ATKEYWORD:
            ;
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_3;
          }
          ignoreStatement();
          label_4:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case S:
              ;
              break;
            default:
              jj_la1[5] = jj_gen;
              break label_4;
            }
            jj_consume_token(S);
          }
        }
      }
      afterImportDeclaration();
      jj_consume_token(0);
    } finally {
        documentHandler.endDocument(source);
    }
  }

  final public void charset() throws ParseException {
  Token n;
    try {
      jj_consume_token(CHARSET_SYM);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_5;
        }
        jj_consume_token(S);
      }
      n = jj_consume_token(STRING);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_6;
        }
        jj_consume_token(S);
      }
      jj_consume_token(SEMICOLON);
    } catch (ParseException e) {
        reportError(getLocator(e.currentToken.next), e);
        skipStatement();
        // reportWarningSkipText(getLocator(), skipStatement());

    } catch (Exception e) {
        reportError(getLocator(), e);
        skipStatement();
        // reportWarningSkipText(getLocator(), skipStatement());

    }
  }

  final public void afterImportDeclaration() throws ParseException {
 String ret;
 Locator l;
    label_7:
    while (true) {
      ;
      if (jj_2_1(5)) {
        listModifyDirective();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VARIABLE:
          variable();
          break;
        case DEBUG_SYM:
        case WARN_SYM:
          debuggingDirective();
          break;
        case MIXIN_SYM:
          mixinDirective();
          break;
        case EACH_SYM:
        case IF_SYM:
          controlDirective();
          break;
        case INCLUDE_SYM:
          includeDirective();
          break;
        case LBRACKET:
        case ANY:
        case PARENT:
        case DOT:
        case COLON:
        case INTERPOLATION:
        case IDENT:
        case HASH:
          styleRule();
          break;
        case MEDIA_SYM:
          media();
          break;
        case PAGE_SYM:
          page();
          break;
        case FONT_FACE_SYM:
          fontFace();
          break;
        default:
          jj_la1[8] = jj_gen;
          l = getLocator();
          ret = skipStatement();
          if ((ret == null) || (ret.length() == 0)) {
              {if (true) return;}
          }
          if (ret.charAt(0) == '@') {
              documentHandler.unrecognizedRule(ret);
          } else {
              reportWarningSkipText(l, ret);
          }
        }
      }
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CDO:
        case CDC:
        case ATKEYWORD:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_8;
        }
        ignoreStatement();
        label_9:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            ;
            break;
          default:
            jj_la1[10] = jj_gen;
            break label_9;
          }
          jj_consume_token(S);
        }
      }
    }
  }

  final public void ignoreStatement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDO:
      jj_consume_token(CDO);
      break;
    case CDC:
      jj_consume_token(CDC);
      break;
    case ATKEYWORD:
      atRuleDeclaration();
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
 * The import statement
 *
 * @exception ParseException exception during the parse
 */
  final public void importDeclaration() throws ParseException {
 Token n;
 String uri;
 MediaListImpl ml = new MediaListImpl();
 boolean isURL = false;
    try {
      jj_consume_token(IMPORT_SYM);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_10;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        n = jj_consume_token(STRING);
                               uri = convertStringIndex(n.image, 1,
                                                        n.image.length() -1);
        break;
      case URL:
        n = jj_consume_token(URL);
               isURL=true;
               uri = n.image.substring(4, n.image.length()-1).trim();
               if ((uri.charAt(0) == '"')
                   || (uri.charAt(0) == '\u005c'')) {
                   uri = uri.substring(1, uri.length()-1);
               }
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_11;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        mediaStatement(ml);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_12;
        }
        jj_consume_token(S);
      }
               if (ml.getLength() == 0) {
                   // see section 6.3 of the CSS2 recommandation.
                   ml.addItem("all");
               }
               documentHandler.importStyle(uri, ml, isURL);
    } catch (ParseException e) {
     reportError(getLocator(), e);
     skipStatement();
     // reportWarningSkipText(getLocator(), skipStatement());

    }
  }

/**
 * @exception ParseException exception during the parse
 */
  final public void media() throws ParseException {
    boolean start = false;
    String ret;
    MediaListImpl ml = new MediaListImpl();
    try {
      jj_consume_token(MEDIA_SYM);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_13;
        }
        jj_consume_token(S);
      }
      mediaStatement(ml);
     start = true; documentHandler.startMedia(ml);
      jj_consume_token(LBRACE);
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_14;
        }
        jj_consume_token(S);
      }
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CDO:
        case LBRACE:
        case DASHMATCH:
        case INCLUDES:
        case PLUS:
        case MINUS:
        case COMMA:
        case SEMICOLON:
        case PRECEDES:
        case SIBLING:
        case LBRACKET:
        case ANY:
        case PARENT:
        case DOT:
        case COLON:
        case INTERPOLATION:
        case NONASCII:
        case DEBUG_SYM:
        case WARN_SYM:
        case STRING:
        case IDENT:
        case NUMBER:
        case URL:
        case PERCENTAGE:
        case HASH:
        case IMPORT_SYM:
        case MEDIA_SYM:
        case CHARSET_SYM:
        case PAGE_SYM:
        case FONT_FACE_SYM:
        case ATKEYWORD:
        case IMPORTANT_SYM:
        case UNICODERANGE:
        case FUNCTION:
        case UNKNOWN:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_15;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEBUG_SYM:
        case WARN_SYM:
          debuggingDirective();
          break;
        case LBRACKET:
        case ANY:
        case PARENT:
        case DOT:
        case COLON:
        case INTERPOLATION:
        case IDENT:
        case HASH:
          styleRule();
          break;
        case CDO:
        case LBRACE:
        case DASHMATCH:
        case INCLUDES:
        case PLUS:
        case MINUS:
        case COMMA:
        case SEMICOLON:
        case PRECEDES:
        case SIBLING:
        case NONASCII:
        case STRING:
        case NUMBER:
        case URL:
        case PERCENTAGE:
        case IMPORT_SYM:
        case MEDIA_SYM:
        case CHARSET_SYM:
        case PAGE_SYM:
        case FONT_FACE_SYM:
        case ATKEYWORD:
        case IMPORTANT_SYM:
        case UNICODERANGE:
        case FUNCTION:
        case UNKNOWN:
          skipUnknownRule();
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RBRACE);
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_16;
        }
        jj_consume_token(S);
      }
    } catch (ParseException e) {
     reportError(getLocator(), e);
     skipStatement();
     // reportWarningSkipText(getLocator(), skipStatement());

    } finally {
     if (start) {
         documentHandler.endMedia(ml);
     }
    }
  }

  final public void mediaStatement(MediaListImpl ml) throws ParseException {
    String m;
    m = medium();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_17;
      }
      jj_consume_token(COMMA);
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_18;
        }
        jj_consume_token(S);
      }
                                   ml.addItem(m);
      m = medium();
    }
     ml.addItem(m);
  }

/**
 * @exception ParseException exception during the parse
 */
  final public String medium() throws ParseException {
 Token n;
    n = jj_consume_token(IDENT);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_19;
      }
      jj_consume_token(S);
    }
                         {if (true) return convertIdent(n.image);}
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public void page() throws ParseException {
 boolean start = false;
 Token n = null;
 String page = null;
 String pseudo = null;
    try {
      jj_consume_token(PAGE_SYM);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_20;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        n = jj_consume_token(IDENT);
        label_21:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            ;
            break;
          default:
            jj_la1[26] = jj_gen;
            break label_21;
          }
          jj_consume_token(S);
        }
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        pseudo = pseudo_page();
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
          if (n != null) {
              page = convertIdent(n.image);
          }
      jj_consume_token(LBRACE);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[29] = jj_gen;
          break label_22;
        }
        jj_consume_token(S);
      }
          start = true;
          documentHandler.startPage(page, pseudo);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTERPOLATION:
      case IDENT:
        declaration();
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_23;
        }
        jj_consume_token(SEMICOLON);
        label_24:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            ;
            break;
          default:
            jj_la1[32] = jj_gen;
            break label_24;
          }
          jj_consume_token(S);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTERPOLATION:
        case IDENT:
          declaration();
          break;
        default:
          jj_la1[33] = jj_gen;
          ;
        }
      }
      jj_consume_token(RBRACE);
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[34] = jj_gen;
          break label_25;
        }
        jj_consume_token(S);
      }
    } catch (ParseException e) {
     if (errorHandler != null) {
         LocatorImpl li = new LocatorImpl(this,
                                          e.currentToken.next.beginLine,
                                          e.currentToken.next.beginColumn-1);
         reportError(li, e);
         skipStatement();
         // reportWarningSkipText(li, skipStatement());
     } else {
         skipStatement();
     }
    } finally {
     if (start) {
         documentHandler.endPage(page, pseudo);
     }
    }
  }

  final public String pseudo_page() throws ParseException {
  Token n;
    jj_consume_token(COLON);
    n = jj_consume_token(IDENT);
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_26;
      }
      jj_consume_token(S);
    }
                             {if (true) return convertIdent(n.image);}
    throw new Error("Missing return statement in function");
  }

  final public void fontFace() throws ParseException {
    boolean start = false;
    try {
      jj_consume_token(FONT_FACE_SYM);
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[36] = jj_gen;
          break label_27;
        }
        jj_consume_token(S);
      }
      jj_consume_token(LBRACE);
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[37] = jj_gen;
          break label_28;
        }
        jj_consume_token(S);
      }
        start = true; documentHandler.startFontFace();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTERPOLATION:
      case IDENT:
        declaration();
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          ;
          break;
        default:
          jj_la1[39] = jj_gen;
          break label_29;
        }
        jj_consume_token(SEMICOLON);
        label_30:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            ;
            break;
          default:
            jj_la1[40] = jj_gen;
            break label_30;
          }
          jj_consume_token(S);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTERPOLATION:
        case IDENT:
          declaration();
          break;
        default:
          jj_la1[41] = jj_gen;
          ;
        }
      }
      jj_consume_token(RBRACE);
      label_31:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[42] = jj_gen;
          break label_31;
        }
        jj_consume_token(S);
      }
    } catch (ParseException e) {
     reportError(getLocator(), e);
     skipStatement();
     // reportWarningSkipText(getLocator(), skipStatement());

    } finally {
     if (start) {
         documentHandler.endFontFace();
     }
    }
  }

/**
 * @exception ParseException exception during the parse
 */
  final public void atRuleDeclaration() throws ParseException {
 Token n;
 String ret;
    n = jj_consume_token(ATKEYWORD);
        ret=skipStatement();
        if ((ret != null) && (ret.charAt(0) == '@')) {
            documentHandler.unrecognizedRule(ret);
        } else {
            reportWarningSkipText(getLocator(), ret);
        }
  }

  final public void skipUnknownRule() throws ParseException {
  Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ATKEYWORD:
      n = jj_consume_token(ATKEYWORD);
      break;
    case CDO:
      n = jj_consume_token(CDO);
      break;
    case CHARSET_SYM:
      n = jj_consume_token(CHARSET_SYM);
      break;
    case COMMA:
      n = jj_consume_token(COMMA);
      break;
    case DASHMATCH:
      n = jj_consume_token(DASHMATCH);
      break;
    case FONT_FACE_SYM:
      n = jj_consume_token(FONT_FACE_SYM);
      break;
    case FUNCTION:
      n = jj_consume_token(FUNCTION);
      break;
    case IMPORTANT_SYM:
      n = jj_consume_token(IMPORTANT_SYM);
      break;
    case IMPORT_SYM:
      n = jj_consume_token(IMPORT_SYM);
      break;
    case INCLUDES:
      n = jj_consume_token(INCLUDES);
      break;
    case LBRACE:
      n = jj_consume_token(LBRACE);
      break;
    case MEDIA_SYM:
      n = jj_consume_token(MEDIA_SYM);
      break;
    case NONASCII:
      n = jj_consume_token(NONASCII);
      break;
    case NUMBER:
      n = jj_consume_token(NUMBER);
      break;
    case PAGE_SYM:
      n = jj_consume_token(PAGE_SYM);
      break;
    case PERCENTAGE:
      n = jj_consume_token(PERCENTAGE);
      break;
    case STRING:
      n = jj_consume_token(STRING);
      break;
    case UNICODERANGE:
      n = jj_consume_token(UNICODERANGE);
      break;
    case URL:
      n = jj_consume_token(URL);
      break;
    case SEMICOLON:
      n = jj_consume_token(SEMICOLON);
      break;
    case PLUS:
      n = jj_consume_token(PLUS);
      break;
    case PRECEDES:
      n = jj_consume_token(PRECEDES);
      break;
    case SIBLING:
      n = jj_consume_token(SIBLING);
      break;
    case MINUS:
      n = jj_consume_token(MINUS);
      break;
    case UNKNOWN:
      n = jj_consume_token(UNKNOWN);
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     String ret;
     Locator loc = getLocator();
     ret=skipStatement();
     if ((ret != null) && (n.image.charAt(0) == '@')) {
         documentHandler.unrecognizedRule(ret);
     } else {
     reportWarningSkipText(loc, ret);
     }
  }

/**
 * @exception ParseException exception during the parse
 */
  final public char combinator() throws ParseException {
char connector = ' ';
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      jj_consume_token(PLUS);
      label_32:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_32;
        }
        jj_consume_token(S);
      }
                   {if (true) return '+';}
      break;
    case PRECEDES:
      jj_consume_token(PRECEDES);
      label_33:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_33;
        }
        jj_consume_token(S);
      }
                     {if (true) return '>';}
      break;
    case SIBLING:
      jj_consume_token(SIBLING);
      label_34:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[46] = jj_gen;
          break label_34;
        }
        jj_consume_token(S);
      }
                     {if (true) return '~';}
      break;
    case S:
      jj_consume_token(S);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case PRECEDES:
      case SIBLING:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
                 connector = '+';
          break;
        case PRECEDES:
          jj_consume_token(PRECEDES);
                   connector = '>';
          break;
        case SIBLING:
          jj_consume_token(SIBLING);
                   connector = '~';
          break;
        default:
          jj_la1[47] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_35:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            ;
            break;
          default:
            jj_la1[48] = jj_gen;
            break label_35;
          }
          jj_consume_token(S);
        }
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
               {if (true) return connector;}
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void microsoftExtension() throws ParseException {
  Token n;
  String name = "";
  String value = "";
    // This is not really taking the syntax of filter rules into account
      n = jj_consume_token(MICROSOFT_RULE);
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_36;
      }
      jj_consume_token(S);
    }
                                    name = n.image;
    jj_consume_token(COLON);
    label_37:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        n = jj_consume_token(IDENT);
                          value += n.image;
        break;
      case NUMBER:
        n = jj_consume_token(NUMBER);
                            value += n.image;
        break;
      case STRING:
        n = jj_consume_token(STRING);
                            value += n.image;
        break;
      case COMMA:
        n = jj_consume_token(COMMA);
                           value += n.image;
        break;
      case INTERPOLATION:
        n = jj_consume_token(INTERPOLATION);
                                   value += n.image;
        break;
      case COLON:
        n = jj_consume_token(COLON);
                           value += n.image;
        break;
      case FUNCTION:
        n = jj_consume_token(FUNCTION);
                              value += n.image;
        break;
      case RPARAN:
        n = jj_consume_token(RPARAN);
                            value += n.image;
        break;
      case EQ:
        n = jj_consume_token(EQ);
                        value += n.image;
        break;
      case DOT:
        n = jj_consume_token(DOT);
                         value += n.image;
        break;
      case S:
        n = jj_consume_token(S);
                       if(value.lastIndexOf(' ') != value.length()-1)
        { value += n.image; }
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
      case EQ:
      case COMMA:
      case DOT:
      case RPARAN:
      case COLON:
      case INTERPOLATION:
      case STRING:
      case IDENT:
      case NUMBER:
      case FUNCTION:
        ;
        break;
      default:
        jj_la1[53] = jj_gen;
        break label_37;
      }
    }
    jj_consume_token(SEMICOLON);
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_38;
      }
      jj_consume_token(S);
    }
          documentHandler.microsoftDirective(name, value);
  }

/**
 * @exception ParseException exception during the parse
 */
  final public String property() throws ParseException {
 Token t;String s = "";
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        t = jj_consume_token(IDENT);
                 s += t.image;
        break;
      case INTERPOLATION:
        t = jj_consume_token(INTERPOLATION);
                                                        s += t.image;
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTERPOLATION:
      case IDENT:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_39;
      }
    }
    label_40:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[57] = jj_gen;
        break label_40;
      }
      jj_consume_token(S);
    }
      {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String variableName() throws ParseException {
 Token n;
    n = jj_consume_token(VARIABLE);
    label_41:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[58] = jj_gen;
        break label_41;
      }
      jj_consume_token(S);
    }
                         {if (true) return convertIdent(n.image.substring(1));}
    throw new Error("Missing return statement in function");
  }

  final public String functionName() throws ParseException {
 Token n;
    n = jj_consume_token(FUNCTION);
    label_42:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[59] = jj_gen;
        break label_42;
      }
      jj_consume_token(S);
    }
                           {if (true) return convertIdent(n.image.substring(0, n.image.length()-1));}
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public void styleRule() throws ParseException {
    boolean start = false;
    ArrayList<String> l = null;
    Token save;
    Locator loc;
    try {
      l = selectorList();
                        save = token;
      jj_consume_token(LBRACE);
      label_43:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[60] = jj_gen;
          break label_43;
        }
        jj_consume_token(S);
      }
         start = true;
         documentHandler.startSelector(l);
      label_44:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
        case ANY:
        case PARENT:
        case DOT:
        case COLON:
        case INTERPOLATION:
        case INCLUDE_SYM:
        case DEBUG_SYM:
        case WARN_SYM:
        case EACH_SYM:
        case IF_SYM:
        case EXTEND_SYM:
        case MICROSOFT_RULE:
        case IDENT:
        case VARIABLE:
        case HASH:
        case MEDIA_SYM:
          ;
          break;
        default:
          jj_la1[61] = jj_gen;
          break label_44;
        }
        if (jj_2_2(5)) {
          ifContentStatement();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EACH_SYM:
          case IF_SYM:
            controlDirective();
            break;
          case MICROSOFT_RULE:
            microsoftExtension();
            break;
          default:
            jj_la1[62] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      jj_consume_token(RBRACE);
      label_45:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[63] = jj_gen;
          break label_45;
        }
        jj_consume_token(S);
      }
    } catch (ThrowedParseException e) {
     if (errorHandler != null) {
         LocatorImpl li = new LocatorImpl(this,
                                          e.e.currentToken.next.beginLine,
                                          e.e.currentToken.next.beginColumn-1);
         reportError(li, e.e);
     }
    } catch (ParseException e) {
     reportError(getLocator(), e);
     skipStatement();
     // reportWarningSkipText(getLocator(), skipStatement());

    } catch (TokenMgrError e) {
     reportWarningSkipText(getLocator(), skipStatement());
    } finally {
     if (start) {
         documentHandler.endSelector();
     }
    }
  }

  final public ArrayList<String> selectorList() throws ParseException {
     ArrayList<String> selectors = new  ArrayList<String>();
     String selector;
    selector = selector();
    label_46:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[64] = jj_gen;
        break label_46;
      }
      jj_consume_token(COMMA);
      label_47:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[65] = jj_gen;
          break label_47;
        }
        jj_consume_token(S);
      }
                                        selectors.add(selector);
      selector = selector();
    }
    selectors.add(selector);
    {if (true) return selectors;}
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public String selector() throws ParseException {
    String selector;
    char    comb;
    try {
      selector = simple_selector(null, ' ');
      label_48:
      while (true) {
        if (jj_2_3(2)) {
          ;
        } else {
          break label_48;
        }
        comb = combinator();
        selector = simple_selector(selector, comb);
      }
      label_49:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[66] = jj_gen;
          break label_49;
        }
        jj_consume_token(S);
      }
       {if (true) return selector;}
    } catch (ParseException e) {
     /*
     Token t = getToken(1);
     StringBuffer s = new StringBuffer();
     s.append(getToken(0).image);
     while ((t.kind != COMMA) && (t.kind != SEMICOLON) 
	    && (t.kind != LBRACE) && (t.kind != EOF)) {
	 s.append(t.image);
	 getNextToken();
	 t = getToken(1);
     }
     reportWarningSkipText(getLocator(), s.toString());
     */
     Token t = getToken(1);
     while ((t.kind != COMMA) && (t.kind != SEMICOLON)
            && (t.kind != LBRACE) && (t.kind != EOF)) {
         getNextToken();
         t = getToken(1);
     }

     {if (true) throw new ThrowedParseException(e);}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public String simple_selector(String selector, char comb) throws ParseException {
    String simple_current = null;
    String cond = null;

    pseudoElt = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANY:
    case PARENT:
    case INTERPOLATION:
    case IDENT:
      simple_current = element_name();
      label_50:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
        case DOT:
        case COLON:
        case HASH:
          ;
          break;
        default:
          jj_la1[67] = jj_gen;
          break label_50;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HASH:
          cond = hash(cond);
          break;
        case DOT:
          cond = _class(cond);
          break;
        case LBRACKET:
          cond = attrib(cond);
          break;
        case COLON:
          cond = pseudo(cond);
          break;
        default:
          jj_la1[68] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case HASH:
      cond = hash(cond);
      label_51:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
        case DOT:
        case COLON:
          ;
          break;
        default:
          jj_la1[69] = jj_gen;
          break label_51;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          cond = _class(cond);
          break;
        case LBRACKET:
          cond = attrib(cond);
          break;
        case COLON:
          cond = pseudo(cond);
          break;
        default:
          jj_la1[70] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case DOT:
      cond = _class(cond);
      label_52:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
        case DOT:
        case COLON:
        case HASH:
          ;
          break;
        default:
          jj_la1[71] = jj_gen;
          break label_52;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HASH:
          cond = hash(cond);
          break;
        case DOT:
          cond = _class(cond);
          break;
        case LBRACKET:
          cond = attrib(cond);
          break;
        case COLON:
          cond = pseudo(cond);
          break;
        default:
          jj_la1[72] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case COLON:
      cond = pseudo(cond);
      label_53:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
        case DOT:
        case COLON:
        case HASH:
          ;
          break;
        default:
          jj_la1[73] = jj_gen;
          break label_53;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HASH:
          cond = hash(cond);
          break;
        case DOT:
          cond = _class(cond);
          break;
        case LBRACKET:
          cond = attrib(cond);
          break;
        case COLON:
          cond = pseudo(cond);
          break;
        default:
          jj_la1[74] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case LBRACKET:
      cond = attrib(cond);
      label_54:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
        case DOT:
        case COLON:
        case HASH:
          ;
          break;
        default:
          jj_la1[75] = jj_gen;
          break label_54;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HASH:
          cond = hash(cond);
          break;
        case DOT:
          cond = _class(cond);
          break;
        case LBRACKET:
          cond = attrib(cond);
          break;
        case COLON:
          cond = pseudo(cond);
          break;
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            if (simple_current == null) {
                simple_current = "";
            }
            if (cond != null) {
                simple_current = simple_current + cond;
            }
            if (selector != null) {
                switch (comb) {
                case ' ':
                    selector = selector + comb + simple_current;
                    break;
                case '+':
                case '>':
                case '~':
                        selector = selector + " " + comb + " " + simple_current;
                    break;
                default:
                    {if (true) throw new ParseException("invalid state. send a bug report");}
                }
            } else {
                selector= simple_current;
            }
            if (pseudoElt != null) {
                selector = selector + pseudoElt;
            }
            {if (true) return selector;}
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public String _class(String pred) throws ParseException {
 Token t;
String s = ".";
    jj_consume_token(DOT);
    label_55:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        t = jj_consume_token(IDENT);
                   s += t.image;
        break;
      case INTERPOLATION:
        t = jj_consume_token(INTERPOLATION);
                                                           s += t.image;
        break;
      default:
        jj_la1[78] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTERPOLATION:
      case IDENT:
        ;
        break;
      default:
        jj_la1[79] = jj_gen;
        break label_55;
      }
    }
          if (pred == null) {
              {if (true) return s;}
          } else {
              {if (true) return pred + s;}
          }
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public String element_name() throws ParseException {
 Token t; String s = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERPOLATION:
    case IDENT:
      label_56:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          t = jj_consume_token(IDENT);
                 s += t.image;
          break;
        case INTERPOLATION:
          t = jj_consume_token(INTERPOLATION);
                                                        s += t.image;
          break;
        default:
          jj_la1[80] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTERPOLATION:
        case IDENT:
          ;
          break;
        default:
          jj_la1[81] = jj_gen;
          break label_56;
        }
      }
      {if (true) return s;}
      break;
    case ANY:
      jj_consume_token(ANY);
      {if (true) return "*";}
      break;
    case PARENT:
      jj_consume_token(PARENT);
      {if (true) return "&";}
      break;
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public String attrib(String pred) throws ParseException {
    int cases = 0;
    Token att = null;
    Token val = null;
    String attValue = null;
    jj_consume_token(LBRACKET);
    label_57:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[83] = jj_gen;
        break label_57;
      }
      jj_consume_token(S);
    }
    att = jj_consume_token(IDENT);
    label_58:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[84] = jj_gen;
        break label_58;
      }
      jj_consume_token(S);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DASHMATCH:
    case CARETMATCH:
    case DOLLARMATCH:
    case STARMATCH:
    case INCLUDES:
    case EQ:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        jj_consume_token(EQ);
                          cases = 1;
        break;
      case INCLUDES:
        jj_consume_token(INCLUDES);
                          cases = 2;
        break;
      case DASHMATCH:
        jj_consume_token(DASHMATCH);
                          cases = 3;
        break;
      case CARETMATCH:
        jj_consume_token(CARETMATCH);
                           cases = 4;
        break;
      case DOLLARMATCH:
        jj_consume_token(DOLLARMATCH);
                            cases = 5;
        break;
      case STARMATCH:
        jj_consume_token(STARMATCH);
                          cases = 6;
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_59:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[86] = jj_gen;
          break label_59;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        val = jj_consume_token(IDENT);
                        attValue = val.image;
        break;
      case STRING:
        val = jj_consume_token(STRING);
                           attValue = val.image;
        break;
      default:
        jj_la1[87] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_60:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[88] = jj_gen;
          break label_60;
        }
        jj_consume_token(S);
      }
      break;
    default:
      jj_la1[89] = jj_gen;
      ;
    }
    jj_consume_token(RBRACKET);
      String name = convertIdent(att.image);
      String c;
      switch (cases) {
          case 0:
          c = name;
          break;
          case 1:
          c = name + "=" + attValue;
          break;
          case 2:
          c = name + "~=" + attValue;
          break;
          case 3:
          c = name + "|=" +attValue;
          break;
          case 4:
          c = name + "^=" +attValue;
          break;
          case 5:
          c = name + "$=" +attValue;
          break;
          case 6:
          c = name + "*=" +attValue;
          break;
          default:
          // never reached.
          c = null;
      }
      c = "[" + c + "]";
      if (pred == null) {
          {if (true) return c;}
      } else {
          {if (true) return pred + c;}
      }
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public String pseudo(String pred) throws ParseException {
 Token n;
Token param;
String d;
boolean isPseudoElement = false;
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
             isPseudoElement=true;
      break;
    default:
      jj_la1[90] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      n = jj_consume_token(IDENT);
            String s = ":" + convertIdent(n.image);
            if (isPseudoElement) {
                if (pseudoElt != null) {
                    {if (true) throw new CSSParseException("duplicate pseudo element definition "
                                                + s, getLocator());}
                } else {
                    pseudoElt = ":"+s;
                    {if (true) return pred;}
                }
            } else {
                String c = s;
                if (pred == null) {
                    {if (true) return c;}
                } else {
                    {if (true) return pred + c;}
                }
            }
      break;
    case FUNCTION:
      n = jj_consume_token(FUNCTION);
      label_61:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[91] = jj_gen;
          break label_61;
        }
        jj_consume_token(S);
      }
      d = skipStatementUntilRightParan();
      jj_consume_token(RPARAN);
                  // accept anything between function and a right parenthesis
                  String f = convertIdent(n.image);
                  String colons = isPseudoElement ? "::" : ":";
                  String pseudofn = colons + f + d + ")";
                      if (pred == null) {
                          {if (true) return pseudofn;}
                      } else {
                          {if (true) return pred + pseudofn;}
                  }
      break;
    default:
      jj_la1[92] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public String hash(String pred) throws ParseException {
 Token n;
    n = jj_consume_token(HASH);
      String d = n.image;
      if (pred == null) {
          {if (true) return d;}
      } else {
          {if (true) return pred + d;}
      }
    throw new Error("Missing return statement in function");
  }

  final public void variable() throws ParseException {
        String name;
        LexicalUnitImpl exp = null;
        boolean guarded = false;
        String raw;
    try {
      name = variableName();
      jj_consume_token(COLON);
      label_62:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[93] = jj_gen;
          break label_62;
        }
        jj_consume_token(S);
      }
      exp = expr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GUARDED_SYM:
        guarded = guarded();
        break;
      default:
        jj_la1[94] = jj_gen;
        ;
      }
      label_63:
      while (true) {
        jj_consume_token(SEMICOLON);
        label_64:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            ;
            break;
          default:
            jj_la1[95] = jj_gen;
            break label_64;
          }
          jj_consume_token(S);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          ;
          break;
        default:
          jj_la1[96] = jj_gen;
          break label_63;
        }
      }
                    documentHandler.variable(name, exp, guarded);
    } catch (JumpException e) {
            skipAfterExpression();
    } catch (NumberFormatException e) {
            if (errorHandler != null) {
                errorHandler.error(new CSSParseException("Invalid number "
                                                  + e.getMessage(),
                                                  getLocator(),
                                                  e));
            }
            reportWarningSkipText(getLocator(), skipAfterExpression());
    } catch (ParseException e) {
            if (errorHandler != null) {
                if (e.currentToken != null) {
                        LocatorImpl li = new LocatorImpl(this,
                                                      e.currentToken.next.beginLine,
                                                      e.currentToken.next.beginColumn-1);
                        reportError(li, e);
                } else {
                        reportError(getLocator(), e);
            }
                skipAfterExpression();
            } else {
                skipAfterExpression();
            }
    }
  }

  final public void controlDirective() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF_SYM:
      ifDirective();
      break;
    case EACH_SYM:
      eachDirective();
      break;
    default:
      jj_la1[97] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ifContentStatement() throws ParseException {
    if (jj_2_4(5)) {
      listModifyDirective();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCLUDE_SYM:
        includeDirective();
        break;
      case MEDIA_SYM:
        media();
        break;
      case EXTEND_SYM:
        extendDirective();
        break;
      case VARIABLE:
        variable();
        break;
      case LBRACKET:
      case ANY:
      case PARENT:
      case DOT:
      case COLON:
      case INTERPOLATION:
      case DEBUG_SYM:
      case WARN_SYM:
      case IDENT:
      case HASH:
        styleRuleOrDeclarationOrNestedProperties();
        break;
      default:
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void ifDirective() throws ParseException {
  Token n = null;
  String evaluator = "";
    jj_consume_token(IF_SYM);
    label_65:
    while (true) {
      n = booleanExpressionToken();
                                   evaluator += n.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
      case EQ:
      case PLUS:
      case MINUS:
      case PRECEDES:
      case SUCCEEDS:
      case DIV:
      case ANY:
      case LPARAN:
      case RPARAN:
      case COMPARE:
      case OR:
      case AND:
      case NOT_EQ:
      case IDENT:
      case NUMBER:
      case VARIABLE:
        ;
        break;
      default:
        jj_la1[99] = jj_gen;
        break label_65;
      }
    }
    jj_consume_token(LBRACE);
    label_66:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[100] = jj_gen;
        break label_66;
      }
      jj_consume_token(S);
    }
    documentHandler.startIfElseDirective();
    documentHandler.ifDirective(evaluator);
    label_67:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case ANY:
      case PARENT:
      case DOT:
      case COLON:
      case INTERPOLATION:
      case INCLUDE_SYM:
      case DEBUG_SYM:
      case WARN_SYM:
      case EXTEND_SYM:
      case IDENT:
      case VARIABLE:
      case HASH:
      case MEDIA_SYM:
        ;
        break;
      default:
        jj_la1[101] = jj_gen;
        break label_67;
      }
      ifContentStatement();
    }
    jj_consume_token(RBRACE);
    label_68:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[102] = jj_gen;
        break label_68;
      }
      jj_consume_token(S);
    }
    label_69:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE_SYM:
        ;
        break;
      default:
        jj_la1[103] = jj_gen;
        break label_69;
      }
      elseDirective();
    }
    documentHandler.endIfElseDirective();
  }

  final public void elseDirective() throws ParseException {
  String evaluator = "";
  Token n = null;
    jj_consume_token(ELSE_SYM);
    label_70:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[104] = jj_gen;
        break label_70;
      }
      jj_consume_token(S);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      jj_consume_token(IF);
      label_71:
      while (true) {
        n = booleanExpressionToken();
                                            evaluator += n.image;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
        case EQ:
        case PLUS:
        case MINUS:
        case PRECEDES:
        case SUCCEEDS:
        case DIV:
        case ANY:
        case LPARAN:
        case RPARAN:
        case COMPARE:
        case OR:
        case AND:
        case NOT_EQ:
        case IDENT:
        case NUMBER:
        case VARIABLE:
          ;
          break;
        default:
          jj_la1[105] = jj_gen;
          break label_71;
        }
      }
      break;
    default:
      jj_la1[106] = jj_gen;
      ;
    }
    jj_consume_token(LBRACE);
    label_72:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[107] = jj_gen;
        break label_72;
      }
      jj_consume_token(S);
    }
    if(!evaluator.trim().equals("")){ documentHandler.ifDirective(evaluator); }
    else{ documentHandler.elseDirective(); }
    label_73:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case ANY:
      case PARENT:
      case DOT:
      case COLON:
      case INTERPOLATION:
      case INCLUDE_SYM:
      case DEBUG_SYM:
      case WARN_SYM:
      case EXTEND_SYM:
      case IDENT:
      case VARIABLE:
      case HASH:
      case MEDIA_SYM:
        ;
        break;
      default:
        jj_la1[108] = jj_gen;
        break label_73;
      }
      ifContentStatement();
    }
    jj_consume_token(RBRACE);
    label_74:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[109] = jj_gen;
        break label_74;
      }
      jj_consume_token(S);
    }
  }

  final public Token booleanExpressionToken() throws ParseException {
  Token n = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARIABLE:
      n = jj_consume_token(VARIABLE);
      break;
    case IDENT:
      n = jj_consume_token(IDENT);
      break;
    case NUMBER:
      n = jj_consume_token(NUMBER);
      break;
    case LPARAN:
      n = jj_consume_token(LPARAN);
      break;
    case RPARAN:
      n = jj_consume_token(RPARAN);
      break;
    case PLUS:
      n = jj_consume_token(PLUS);
      break;
    case MINUS:
      n = jj_consume_token(MINUS);
      break;
    case DIV:
      n = jj_consume_token(DIV);
      break;
    case ANY:
      n = jj_consume_token(ANY);
      break;
    case COMPARE:
      n = jj_consume_token(COMPARE);
      break;
    case EQ:
      n = jj_consume_token(EQ);
      break;
    case PRECEDES:
      n = jj_consume_token(PRECEDES);
      break;
    case SUCCEEDS:
      n = jj_consume_token(SUCCEEDS);
      break;
    case OR:
      n = jj_consume_token(OR);
      break;
    case AND:
      n = jj_consume_token(AND);
      break;
    case S:
      n = jj_consume_token(S);
      break;
    case NOT_EQ:
      n = jj_consume_token(NOT_EQ);
      break;
    default:
      jj_la1[110] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
   {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public void eachDirective() throws ParseException {
  Token var;
  ArrayList<String> list = null;
  String listVariable = null;
    jj_consume_token(EACH_SYM);
    label_75:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[111] = jj_gen;
        break label_75;
      }
      jj_consume_token(S);
    }
    var = jj_consume_token(VARIABLE);
    label_76:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[112] = jj_gen;
        break label_76;
      }
      jj_consume_token(S);
    }
    jj_consume_token(EACH_IN);
    label_77:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[113] = jj_gen;
        break label_77;
      }
      jj_consume_token(S);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      list = stringList();
   documentHandler.startEachDirective(var.image, list);
      break;
    case VARIABLE:
      listVariable = variableName();
   documentHandler.startEachDirective(var.image, listVariable);
      break;
    default:
      jj_la1[114] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(LBRACE);
    label_78:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[115] = jj_gen;
        break label_78;
      }
      jj_consume_token(S);
    }
    label_79:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case ANY:
      case PARENT:
      case DOT:
      case COLON:
      case INTERPOLATION:
      case INCLUDE_SYM:
      case DEBUG_SYM:
      case WARN_SYM:
      case EXTEND_SYM:
      case IDENT:
      case VARIABLE:
      case HASH:
      case MEDIA_SYM:
        ;
        break;
      default:
        jj_la1[116] = jj_gen;
        break label_79;
      }
      ifContentStatement();
    }
    jj_consume_token(RBRACE);
    label_80:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[117] = jj_gen;
        break label_80;
      }
      jj_consume_token(S);
    }
    documentHandler.endEachDirective();
  }

  final public ArrayList<String > stringList() throws ParseException {
        ArrayList<String > strings = new ArrayList<String >();
        Token input;
    input = jj_consume_token(IDENT);
    label_81:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[118] = jj_gen;
        break label_81;
      }
      jj_consume_token(S);
    }
          strings.add(input.image);
    label_82:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[119] = jj_gen;
        break label_82;
      }
      jj_consume_token(COMMA);
      label_83:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[120] = jj_gen;
          break label_83;
        }
        jj_consume_token(S);
      }
      input = jj_consume_token(IDENT);
                                               strings.add(input.image);
      label_84:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[121] = jj_gen;
          break label_84;
        }
        jj_consume_token(S);
      }
    }
          {if (true) return strings;}
    throw new Error("Missing return statement in function");
  }

  final public void mixinDirective() throws ParseException {
    String name;
    ArrayList<VariableNode> args = null;
    String body;
    jj_consume_token(MIXIN_SYM);
    label_85:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[122] = jj_gen;
        break label_85;
      }
      jj_consume_token(S);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERPOLATION:
    case IDENT:
      name = property();
      break;
    case FUNCTION:
      name = functionName();
      args = arglist();
      jj_consume_token(RPARAN);
      label_86:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[123] = jj_gen;
          break label_86;
        }
        jj_consume_token(S);
      }
      break;
    default:
      jj_la1[124] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(LBRACE);
    label_87:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[125] = jj_gen;
        break label_87;
      }
      jj_consume_token(S);
    }
     documentHandler.startMixinDirective(name, args);
    label_88:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case ANY:
      case PARENT:
      case DOT:
      case COLON:
      case INTERPOLATION:
      case INCLUDE_SYM:
      case DEBUG_SYM:
      case WARN_SYM:
      case EACH_SYM:
      case IF_SYM:
      case EXTEND_SYM:
      case IDENT:
      case VARIABLE:
      case HASH:
      case MEDIA_SYM:
      case PAGE_SYM:
      case FONT_FACE_SYM:
        ;
        break;
      default:
        jj_la1[126] = jj_gen;
        break label_88;
      }
      if (jj_2_5(5)) {
        ifContentStatement();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EACH_SYM:
        case IF_SYM:
          controlDirective();
          break;
        case FONT_FACE_SYM:
          fontFace();
          break;
        case PAGE_SYM:
          page();
          break;
        default:
          jj_la1[127] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    jj_consume_token(RBRACE);
    label_89:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[128] = jj_gen;
        break label_89;
      }
      jj_consume_token(S);
    }
     documentHandler.endMixinDirective(name, args);
  }

  final public ArrayList<VariableNode> arglist() throws ParseException {
    ArrayList<VariableNode> args = new ArrayList<VariableNode>();
    VariableNode arg;
    boolean hasNonOptionalArgument = false;
    arg = mixinArg();
    label_90:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[129] = jj_gen;
        break label_90;
      }
      jj_consume_token(COMMA);
      label_91:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[130] = jj_gen;
          break label_91;
        }
        jj_consume_token(S);
      }
                                      hasNonOptionalArgument = checkMixinForNonOptionalArguments(arg, hasNonOptionalArgument); args.add(arg);
      arg = mixinArg();
    }
      hasNonOptionalArgument = checkMixinForNonOptionalArguments(arg, hasNonOptionalArgument); args.add(arg);
        {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

  boolean checkMixinForNonOptionalArguments(VariableNode arg, boolean hasNonOptionalArguments) throws ParseException {
        boolean currentArgHasArguments = arg.getExpr() != null && arg.getExpr().getLexicalUnitType() == LexicalUnitImpl.SCSS_VARIABLE && arg.getExpr().getNextLexicalUnit() != null;

        if(currentArgHasArguments)
        {
                if(hasNonOptionalArguments)
                {
                        throw new ParseException("Sass Error: Required argument $"+ arg.getName() +" must come before any optional arguments.");
                }
                return hasNonOptionalArguments;
        }else
        {
        return true;
        }
  }

  final public VariableNode mixinArg() throws ParseException {
    String name;
    Token variable = null;
    LexicalUnitImpl first = null;
    LexicalUnitImpl prev = null;
    LexicalUnitImpl next = null;
    name = variableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
    case VARIABLE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        jj_consume_token(COLON);
        label_92:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            ;
            break;
          default:
            jj_la1[131] = jj_gen;
            break label_92;
          }
          jj_consume_token(S);
        }
        first = nonVariableTerm(null);
        prev = first;
        label_93:
        while (true) {
          if (jj_2_6(3)) {
            ;
          } else {
            break label_93;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            jj_consume_token(COMMA);
            label_94:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case S:
                ;
                break;
              default:
                jj_la1[132] = jj_gen;
                break label_94;
              }
              jj_consume_token(S);
            }
            break;
          default:
            jj_la1[133] = jj_gen;
            ;
          }
          prev = nonVariableTerm(prev);
        }
        break;
      case VARIABLE:
        variable = jj_consume_token(VARIABLE);
                                    first = LexicalUnitImpl.createVariable(token.beginLine, token.beginColumn,
                 prev, variable.image);
        break;
      default:
        jj_la1[134] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[135] = jj_gen;
      ;
    }
        VariableNode arg = new VariableNode(name, first, false);
        {if (true) return arg;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<LexicalUnitImpl> argValuelist() throws ParseException {
    ArrayList<LexicalUnitImpl> args = new ArrayList<LexicalUnitImpl>();
    LexicalUnitImpl first = null;
    LexicalUnitImpl next = null;
    LexicalUnitImpl prev = null;
    first = term(null);
                         args.add(first); prev = first;
    label_95:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
      case DOT:
      case COLON:
      case STRING:
      case IDENT:
      case NUMBER:
      case URL:
      case VARIABLE:
      case PERCENTAGE:
      case PT:
      case MM:
      case CM:
      case PC:
      case IN:
      case PX:
      case EMS:
      case EXS:
      case DEG:
      case RAD:
      case GRAD:
      case MS:
      case SECOND:
      case HZ:
      case KHZ:
      case DIMEN:
      case HASH:
      case UNICODERANGE:
      case FUNCTION:
        ;
        break;
      default:
        jj_la1[136] = jj_gen;
        break label_95;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        jj_consume_token(COLON);
        label_96:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            ;
            break;
          default:
            jj_la1[137] = jj_gen;
            break label_96;
          }
          jj_consume_token(S);
        }
        break;
      default:
        jj_la1[138] = jj_gen;
        ;
      }
      next = term(prev);
                                                                                              prev.setNextLexicalUnit(next); prev = next;
    }
    label_97:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[139] = jj_gen;
        break label_97;
      }
      jj_consume_token(COMMA);
      label_98:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[140] = jj_gen;
          break label_98;
        }
        jj_consume_token(S);
      }
      first = term(null);
                         args.add(first); prev = first;
      label_99:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
        case DOT:
        case COLON:
        case STRING:
        case IDENT:
        case NUMBER:
        case URL:
        case VARIABLE:
        case PERCENTAGE:
        case PT:
        case MM:
        case CM:
        case PC:
        case IN:
        case PX:
        case EMS:
        case EXS:
        case DEG:
        case RAD:
        case GRAD:
        case MS:
        case SECOND:
        case HZ:
        case KHZ:
        case DIMEN:
        case HASH:
        case UNICODERANGE:
        case FUNCTION:
          ;
          break;
        default:
          jj_la1[141] = jj_gen;
          break label_99;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COLON:
          jj_consume_token(COLON);
          label_100:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case S:
              ;
              break;
            default:
              jj_la1[142] = jj_gen;
              break label_100;
            }
            jj_consume_token(S);
          }
          break;
        default:
          jj_la1[143] = jj_gen;
          ;
        }
        next = term(prev);
                                                                                              prev.setNextLexicalUnit(next); prev = next;
      }
    }
     {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

  final public void includeDirective() throws ParseException {
    String name;
    ArrayList<LexicalUnitImpl> args=null;
    jj_consume_token(INCLUDE_SYM);
    label_101:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[144] = jj_gen;
        break label_101;
      }
      jj_consume_token(S);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERPOLATION:
    case IDENT:
      name = property();
      break;
    case VARIABLE:
      name = variableName();
                                              name = "$"+name;
      break;
    case FUNCTION:
      name = functionName();
      args = argValuelist();
      jj_consume_token(RPARAN);
      break;
    default:
      jj_la1[145] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_102:
    while (true) {
      jj_consume_token(SEMICOLON);
      label_103:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[146] = jj_gen;
          break label_103;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        ;
        break;
      default:
        jj_la1[147] = jj_gen;
        break label_102;
      }
    }
            documentHandler.includeDirective(name, args);
  }

  final public String interpolation() throws ParseException {
  Token n;
    n = jj_consume_token(INTERPOLATION);
    {if (true) return n.image;}
    throw new Error("Missing return statement in function");
  }

  final public void listModifyDirective() throws ParseException {
    if (jj_2_7(5)) {
      removeDirective();
    } else if (jj_2_8(5)) {
      appendDirective();
    } else if (jj_2_9(5)) {
      containsDirective();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
 * @exception ParseException exception during the parse
 */
  final public void appendDirective() throws ParseException {
        String list = null;
        String remove = null;
        String separator = null;
        String variable = null;
        Token n = null;
    n = jj_consume_token(VARIABLE);
                    variable = n.image;
    label_104:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[148] = jj_gen;
        break label_104;
      }
      jj_consume_token(S);
    }
    jj_consume_token(COLON);
    label_105:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[149] = jj_gen;
        break label_105;
      }
      jj_consume_token(S);
    }
    jj_consume_token(APPEND);
    label_106:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[150] = jj_gen;
        break label_106;
      }
      jj_consume_token(S);
    }
    list = listModifyDirectiveArgs(0);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPARAN:
      jj_consume_token(RPARAN);
      break;
    default:
      jj_la1[151] = jj_gen;
      ;
    }
    jj_consume_token(COMMA);
    label_107:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[152] = jj_gen;
        break label_107;
      }
      jj_consume_token(S);
    }
    remove = listModifyDirectiveArgs(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      label_108:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[153] = jj_gen;
          break label_108;
        }
        jj_consume_token(S);
      }
      n = jj_consume_token(IDENT);
                                     separator = n.image;
      label_109:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[154] = jj_gen;
          break label_109;
        }
        jj_consume_token(S);
      }
      break;
    default:
      jj_la1[155] = jj_gen;
      ;
    }
    jj_consume_token(RPARAN);
    label_110:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[156] = jj_gen;
        break label_110;
      }
      jj_consume_token(S);
    }
    jj_consume_token(SEMICOLON);
    label_111:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[157] = jj_gen;
        break label_111;
      }
      jj_consume_token(S);
    }
    documentHandler.appendDirective(variable,list,remove,separator);
  }

/**
 * @exception ParseException exception during the parse
 */
  final public void removeDirective() throws ParseException {
        String list = null;
        String remove = null;
        String separator = null;
        String variable = null;
        Token n = null;
    n = jj_consume_token(VARIABLE);
                    variable = n.image;
    label_112:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[158] = jj_gen;
        break label_112;
      }
      jj_consume_token(S);
    }
    jj_consume_token(COLON);
    label_113:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[159] = jj_gen;
        break label_113;
      }
      jj_consume_token(S);
    }
    jj_consume_token(REMOVE);
    label_114:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[160] = jj_gen;
        break label_114;
      }
      jj_consume_token(S);
    }
    list = listModifyDirectiveArgs(0);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPARAN:
      jj_consume_token(RPARAN);
      break;
    default:
      jj_la1[161] = jj_gen;
      ;
    }
    jj_consume_token(COMMA);
    label_115:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[162] = jj_gen;
        break label_115;
      }
      jj_consume_token(S);
    }
    remove = listModifyDirectiveArgs(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      label_116:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[163] = jj_gen;
          break label_116;
        }
        jj_consume_token(S);
      }
      n = jj_consume_token(IDENT);
                                     separator = n.image;
      label_117:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[164] = jj_gen;
          break label_117;
        }
        jj_consume_token(S);
      }
      break;
    default:
      jj_la1[165] = jj_gen;
      ;
    }
    jj_consume_token(RPARAN);
    label_118:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[166] = jj_gen;
        break label_118;
      }
      jj_consume_token(S);
    }
    jj_consume_token(SEMICOLON);
    label_119:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[167] = jj_gen;
        break label_119;
      }
      jj_consume_token(S);
    }
    documentHandler.removeDirective(variable,list,remove,separator);
  }

/**
 * @exception ParseException exception during the parse
 */
  final public void containsDirective() throws ParseException {
        String list = null;
        String remove = null;
        String separator = null;
        String variable = null;
        Token n = null;
    n = jj_consume_token(VARIABLE);
                    variable = n.image;
    label_120:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[168] = jj_gen;
        break label_120;
      }
      jj_consume_token(S);
    }
    jj_consume_token(COLON);
    label_121:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[169] = jj_gen;
        break label_121;
      }
      jj_consume_token(S);
    }
    jj_consume_token(CONTAINS);
    label_122:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[170] = jj_gen;
        break label_122;
      }
      jj_consume_token(S);
    }
    list = listModifyDirectiveArgs(0);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPARAN:
      jj_consume_token(RPARAN);
      break;
    default:
      jj_la1[171] = jj_gen;
      ;
    }
    jj_consume_token(COMMA);
    label_123:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[172] = jj_gen;
        break label_123;
      }
      jj_consume_token(S);
    }
    remove = listModifyDirectiveArgs(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      label_124:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[173] = jj_gen;
          break label_124;
        }
        jj_consume_token(S);
      }
      n = jj_consume_token(IDENT);
                                     separator = n.image;
      label_125:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[174] = jj_gen;
          break label_125;
        }
        jj_consume_token(S);
      }
      break;
    default:
      jj_la1[175] = jj_gen;
      ;
    }
    jj_consume_token(RPARAN);
    label_126:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[176] = jj_gen;
        break label_126;
      }
      jj_consume_token(S);
    }
    jj_consume_token(SEMICOLON);
    label_127:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[177] = jj_gen;
        break label_127;
      }
      jj_consume_token(S);
    }
    documentHandler.containsDirective(variable,list,remove,separator);
  }

  String listModifyDirectiveArgs(int nest) throws ParseException {
        String list = "";
        int nesting = nest;
        Token t = null;

        while(true)
        {
                t = getToken(1);
                String s = t.image;
                if(t.kind == VARIABLE||t.kind == IDENT)
                {
                  list += s;
                }else if(s.toLowerCase().equals("auto")||s.toLowerCase().equals("space")||s.toLowerCase().equals("comma"))
                {
                        int i = 2;
                        Token temp = getToken(i);
                        boolean isLast = true;
                        while(temp.kind != SEMICOLON)
                        {
                                if(temp.kind != RPARAN || temp.kind != S)
                                {
                                  isLast = false;
                                }
                                i++;
                                temp = getToken(i);
                        }

                        if(isLast)
                        {
                        return list;
                        }
                }
                else if(t.kind == STRING)
                {
                        list += s.substring(1,s.length()).substring(0,s.length()-2);

                }else if(t.kind == LPARAN)
                {
                        nesting++;
                        if(nesting > nest+1)
                        {
                                throw new CSSParseException("Only one ( ) pair per parameter allowed", getLocator());
                        }
                }else if(t.kind == RPARAN)
                {
                        nesting--;
                        if(nesting == 0)
                        {
                                return list;
                        }
                } else if(t.kind == COMMA)
                {
                        if(nesting == nest)
                        {
                          return list;
                        }else
                        {
                          list += ",";
                        }

                }else if(t.kind == S)
                {
                  list += " ";
                } else if(t.kind == LBRACE)
                {
                  throw new CSSParseException("Invalid token,'{' found", getLocator());
                }

                getNextToken();
        }
  }

  final public Node returnDirective() throws ParseException {
    String raw;
    raw = skipStatement();
         {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public void debuggingDirective() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEBUG_SYM:
      debugDirective();
      break;
    case WARN_SYM:
      warnDirective();
      break;
    default:
      jj_la1[178] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void debugDirective() throws ParseException {
    jj_consume_token(DEBUG_SYM);
    String content = skipStatementUntilSemiColon();
    // TODO should evaluate the content expression, call documentHandler.debugDirective() etc.
    System.out.println(content);
    label_128:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[179] = jj_gen;
        break label_128;
      }
      jj_consume_token(S);
    }
  }

  final public void warnDirective() throws ParseException {
    jj_consume_token(WARN_SYM);
    String content = skipStatementUntilSemiColon();
    // TODO should evaluate the content expression, call documentHandler.warnDirective() etc.
    System.err.println(content);
    label_129:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[180] = jj_gen;
        break label_129;
      }
      jj_consume_token(S);
    }
  }

  final public Node forDirective() throws ParseException {
    String var;
    String from;
    String to;
    boolean exclusive;
    String body;
    Token tok;
    var = variableName();
        int[] toThrough = {TO, THROUGH};
        from = skipStatementUntil(toThrough);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TO:
      tok = jj_consume_token(TO);
                 exclusive = true;
      break;
    case THROUGH:
      tok = jj_consume_token(THROUGH);
                       exclusive = false;
      break;
    default:
      jj_la1[181] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    to = skipStatementUntilLeftBrace();
    label_130:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[182] = jj_gen;
        break label_130;
      }
      jj_consume_token(S);
    }
    body = skipStatement();
     {if (true) return documentHandler.forDirective(var, from, to, exclusive, body);}
    throw new Error("Missing return statement in function");
  }

  final public Node whileDirective() throws ParseException {
    String condition;
    String body;
    condition = skipStatementUntilLeftBrace();
    body = skipStatement();
        {if (true) return documentHandler.whileDirective(condition, body);}
    throw new Error("Missing return statement in function");
  }

  final public void extendDirective() throws ParseException {
 ArrayList<String> list;
    jj_consume_token(EXTEND_SYM);
    label_131:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[183] = jj_gen;
        break label_131;
      }
      jj_consume_token(S);
    }
    list = selectorList();
    label_132:
    while (true) {
      jj_consume_token(SEMICOLON);
      label_133:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[184] = jj_gen;
          break label_133;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        ;
        break;
      default:
        jj_la1[185] = jj_gen;
        break label_132;
      }
    }
     documentHandler.extendDirective(list);
  }

  Node importDirective() throws ParseException {
    return null;
  }

  Node charsetDirective() throws ParseException {
    return null;
  }

  Node mozDocumentDirective() throws ParseException {
    return null;
  }

  Node supportsDirective() throws ParseException {
    return null;
  }

  final public void nestedProperties() throws ParseException {
 String name;
LexicalUnit exp;
    name = property();
    jj_consume_token(COLON);
    label_134:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[186] = jj_gen;
        break label_134;
      }
      jj_consume_token(S);
    }
    jj_consume_token(LBRACE);
    label_135:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[187] = jj_gen;
        break label_135;
      }
      jj_consume_token(S);
    }
      documentHandler.startNestedProperties(name);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERPOLATION:
    case IDENT:
      declaration();
      break;
    default:
      jj_la1[188] = jj_gen;
      ;
    }
    label_136:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        ;
        break;
      default:
        jj_la1[189] = jj_gen;
        break label_136;
      }
      jj_consume_token(SEMICOLON);
      label_137:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[190] = jj_gen;
          break label_137;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTERPOLATION:
      case IDENT:
        declaration();
        break;
      default:
        jj_la1[191] = jj_gen;
        ;
      }
    }
    jj_consume_token(RBRACE);
      documentHandler.endNestedProperties(name);
    label_138:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[192] = jj_gen;
        break label_138;
      }
      jj_consume_token(S);
    }
  }

/**
 * @exception ParseException exception during the parse
 */
  final public void styleRuleOrDeclarationOrNestedProperties() throws ParseException {
    try {
      if (jj_2_10(5)) {
        styleRule();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEBUG_SYM:
        case WARN_SYM:
          debuggingDirective();
          break;
        case INTERPOLATION:
        case IDENT:
          declarationOrNestedProperties();
          break;
        default:
          jj_la1[193] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (JumpException e) {
     skipAfterExpression();
     // reportWarningSkipText(getLocator(), skipAfterExpression());

    } catch (ParseException e) {
     if (errorHandler != null) {
         if (e.currentToken != null) {
             LocatorImpl li = new LocatorImpl(this,
                                              e.currentToken.next.beginLine,
                                              e.currentToken.next.beginColumn-1);
             reportError(li, e);
         } else {
             reportError(getLocator(), e);
         }
         skipAfterExpression();
         /*
         LocatorImpl loc = (LocatorImpl) getLocator();
         loc.column--;
         reportWarningSkipText(loc, skipAfterExpression());
         */
     } else {
         skipAfterExpression();
     }
    }
  }

/**
 * @exception ParseException exception during the parse
 */
  final public void declarationOrNestedProperties() throws ParseException {
  boolean important = false;
  String name;
  LexicalUnitImpl exp;
  Token save;
  String comment = null;
    try {
      name = property();
       save = token;
      jj_consume_token(COLON);
      label_139:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[194] = jj_gen;
          break label_139;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
      case DOT:
      case STRING:
      case IDENT:
      case NUMBER:
      case URL:
      case VARIABLE:
      case PERCENTAGE:
      case PT:
      case MM:
      case CM:
      case PC:
      case IN:
      case PX:
      case EMS:
      case EXS:
      case DEG:
      case RAD:
      case GRAD:
      case MS:
      case SECOND:
      case HZ:
      case KHZ:
      case DIMEN:
      case HASH:
      case UNICODERANGE:
      case FUNCTION:
        exp = expr();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPORTANT_SYM:
          important = prio();
          break;
        default:
          jj_la1[195] = jj_gen;
          ;
        }
         Token next = getToken(1);
         if(next.kind == SEMICOLON || next.kind == RBRACE){
             while(next.kind == SEMICOLON){
                 skipStatement();
                 next = getToken(1);
             }
             if(token.specialToken!=null){
                 documentHandler.property(name, exp, important, token.specialToken.image);
             }else{
                 documentHandler.property(name, exp, important, null);
             }
         }
        break;
      case LBRACE:
        jj_consume_token(LBRACE);
        label_140:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            ;
            break;
          default:
            jj_la1[196] = jj_gen;
            break label_140;
          }
          jj_consume_token(S);
        }
         documentHandler.startNestedProperties(name);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTERPOLATION:
        case IDENT:
          declaration();
          break;
        default:
          jj_la1[197] = jj_gen;
          ;
        }
        label_141:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEMICOLON:
            ;
            break;
          default:
            jj_la1[198] = jj_gen;
            break label_141;
          }
          jj_consume_token(SEMICOLON);
          label_142:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case S:
              ;
              break;
            default:
              jj_la1[199] = jj_gen;
              break label_142;
            }
            jj_consume_token(S);
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INTERPOLATION:
          case IDENT:
            declaration();
            break;
          default:
            jj_la1[200] = jj_gen;
            ;
          }
        }
        jj_consume_token(RBRACE);
        label_143:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            ;
            break;
          default:
            jj_la1[201] = jj_gen;
            break label_143;
          }
          jj_consume_token(S);
        }
         documentHandler.endNestedProperties(name);
        break;
      default:
        jj_la1[202] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (JumpException e) {
     skipAfterExpression();
     // reportWarningSkipText(getLocator(), skipAfterExpression());

    } catch (NumberFormatException e) {
     if (errorHandler != null) {
         errorHandler.error(new CSSParseException("Invalid number "
                                                  + e.getMessage(),
                                                  getLocator(),
                                                  e));
     }
     reportWarningSkipText(getLocator(), skipAfterExpression());
    } catch (ParseException e) {
     if (errorHandler != null) {
         if (e.currentToken != null) {
             LocatorImpl li = new LocatorImpl(this,
                                              e.currentToken.next.beginLine,
                                              e.currentToken.next.beginColumn-1);
             reportError(li, e);
         } else {
             reportError(getLocator(), e);
         }
         skipAfterExpression();
         /*
         LocatorImpl loc = (LocatorImpl) getLocator();
         loc.column--;
         reportWarningSkipText(loc, skipAfterExpression());
         */
     } else {
         skipAfterExpression();
     }
    }
  }

/**
 * @exception ParseException exception during the parse
 */
  final public void declaration() throws ParseException {
  boolean important = false;
  String name;
  LexicalUnit exp;
  Token save;
    try {
      name = property();
       save = token;
      jj_consume_token(COLON);
      label_144:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[203] = jj_gen;
          break label_144;
        }
        jj_consume_token(S);
      }
      exp = expr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORTANT_SYM:
        important = prio();
        break;
      default:
        jj_la1[204] = jj_gen;
        ;
      }
         documentHandler.property(name, exp, important);
    } catch (JumpException e) {
     skipAfterExpression();
     // reportWarningSkipText(getLocator(), skipAfterExpression());

    } catch (NumberFormatException e) {
     if (errorHandler != null) {
         errorHandler.error(new CSSParseException("Invalid number "
                                                  + e.getMessage(),
                                                  getLocator(),
                                                  e));
     }
     reportWarningSkipText(getLocator(), skipAfterExpression());
    } catch (ParseException e) {
     if (errorHandler != null) {
         if (e.currentToken != null) {
             LocatorImpl li = new LocatorImpl(this,
                                              e.currentToken.next.beginLine,
                                              e.currentToken.next.beginColumn-1);
             reportError(li, e);
         } else {
             reportError(getLocator(), e);
         }
         skipAfterExpression();
         /*
	 LocatorImpl loc = (LocatorImpl) getLocator();
	 loc.column--;
	 reportWarningSkipText(loc, skipAfterExpression());
	 */
     } else {
         skipAfterExpression();
     }
    }
  }

/**
 * @exception ParseException exception during the parse
 */
  final public boolean prio() throws ParseException {
    jj_consume_token(IMPORTANT_SYM);
    label_145:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[205] = jj_gen;
        break label_145;
      }
      jj_consume_token(S);
    }
                             {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final public boolean guarded() throws ParseException {
    jj_consume_token(GUARDED_SYM);
    label_146:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[206] = jj_gen;
        break label_146;
      }
      jj_consume_token(S);
    }
                          {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public LexicalUnitImpl operator(LexicalUnitImpl prev) throws ParseException {
 Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIV:
      n = jj_consume_token(DIV);
      label_147:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[207] = jj_gen;
          break label_147;
        }
        jj_consume_token(S);
      }
                 {if (true) return LexicalUnitImpl.createSlash(n.beginLine,
                                                       n.beginColumn,
                                                       prev);}
      break;
    case COMMA:
      n = jj_consume_token(COMMA);
      label_148:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[208] = jj_gen;
          break label_148;
        }
        jj_consume_token(S);
      }
                   {if (true) return LexicalUnitImpl.createComma(n.beginLine,
                                                         n.beginColumn,
                                                         prev);}
      break;
    default:
      jj_la1[209] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public LexicalUnitImpl expr() throws ParseException {
    LexicalUnitImpl first, res;
    char op;
    first = term(null);
                      res = first;
    label_149:
    while (true) {
      if (jj_2_11(2)) {
        ;
      } else {
        break label_149;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case DIV:
        res = operator(res);
        break;
      default:
        jj_la1[210] = jj_gen;
        ;
      }
      res = term(res);
    }
    {if (true) return first;}
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public char unaryOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
      jj_consume_token(MINUS);
        {if (true) return '-';}
      break;
    case PLUS:
      jj_consume_token(PLUS);
        {if (true) return '+';}
      break;
    default:
      jj_la1[211] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public LexicalUnitImpl term(LexicalUnitImpl prev) throws ParseException {
  LexicalUnitImpl result = null;
  Token n = null;
  char op = ' ';
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
    case DOT:
    case STRING:
    case IDENT:
    case NUMBER:
    case URL:
    case PERCENTAGE:
    case PT:
    case MM:
    case CM:
    case PC:
    case IN:
    case PX:
    case EMS:
    case EXS:
    case DEG:
    case RAD:
    case GRAD:
    case MS:
    case SECOND:
    case HZ:
    case KHZ:
    case DIMEN:
    case HASH:
    case UNICODERANGE:
    case FUNCTION:
      result = nonVariableTerm(prev);
      break;
    case VARIABLE:
      result = variableTerm(prev);
      break;
    default:
      jj_la1[212] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public LexicalUnitImpl variableTerm(LexicalUnitImpl prev) throws ParseException {
  LexicalUnitImpl result = null;
  String varName = "";
    varName = variableName();
          result = LexicalUnitImpl.createVariable(token.beginLine, token.beginColumn,
                 prev, varName); {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public LexicalUnitImpl nonVariableTerm(LexicalUnitImpl prev) throws ParseException {
LexicalUnitImpl result = null;
  Token n = null;
  char op = ' ';
  String varName;
  String s = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
    case NUMBER:
    case PERCENTAGE:
    case PT:
    case MM:
    case CM:
    case PC:
    case IN:
    case PX:
    case EMS:
    case EXS:
    case DEG:
    case RAD:
    case GRAD:
    case MS:
    case SECOND:
    case HZ:
    case KHZ:
    case DIMEN:
    case FUNCTION:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        op = unaryOperator();
        break;
      default:
        jj_la1[213] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
        n = jj_consume_token(NUMBER);
          result = LexicalUnitImpl.createNumber(n.beginLine, n.beginColumn,
                                                prev, number(op, n, 0));
        break;
      case PERCENTAGE:
        n = jj_consume_token(PERCENTAGE);
          result = LexicalUnitImpl.createPercentage(n.beginLine, n.beginColumn,
                                                    prev, number(op, n, 1));
        break;
      case PT:
        n = jj_consume_token(PT);
          result = LexicalUnitImpl.createPT(n.beginLine, n.beginColumn,
                                            prev, number(op, n, 2));
        break;
      case CM:
        n = jj_consume_token(CM);
          result = LexicalUnitImpl.createCM(n.beginLine, n.beginColumn,
                                            prev, number(op, n, 2));
        break;
      case MM:
        n = jj_consume_token(MM);
          result = LexicalUnitImpl.createMM(n.beginLine, n.beginColumn,
                                            prev, number(op, n, 2));
        break;
      case PC:
        n = jj_consume_token(PC);
          result = LexicalUnitImpl.createPC(n.beginLine, n.beginColumn,
                                            prev, number(op, n, 2));
        break;
      case IN:
        n = jj_consume_token(IN);
          result = LexicalUnitImpl.createIN(n.beginLine, n.beginColumn,
                                            prev, number(op, n, 2));
        break;
      case PX:
        n = jj_consume_token(PX);
          result = LexicalUnitImpl.createPX(n.beginLine, n.beginColumn,
                                            prev, number(op, n, 2));
        break;
      case EMS:
        n = jj_consume_token(EMS);
          result = LexicalUnitImpl.createEMS(n.beginLine, n.beginColumn,
                                             prev, number(op, n, 2));
        break;
      case EXS:
        n = jj_consume_token(EXS);
          result = LexicalUnitImpl.createEXS(n.beginLine, n.beginColumn,
                                             prev, number(op, n, 2));
        break;
      case DEG:
        n = jj_consume_token(DEG);
          result = LexicalUnitImpl.createDEG(n.beginLine, n.beginColumn,
                                             prev, number(op, n, 3));
        break;
      case RAD:
        n = jj_consume_token(RAD);
          result = LexicalUnitImpl.createRAD(n.beginLine, n.beginColumn,
                                             prev, number(op, n, 3));
        break;
      case GRAD:
        n = jj_consume_token(GRAD);
          result = LexicalUnitImpl.createGRAD(n.beginLine, n.beginColumn,
                                              prev, number(op, n, 3));
        break;
      case SECOND:
        n = jj_consume_token(SECOND);
          result = LexicalUnitImpl.createS(n.beginLine, n.beginColumn,
                                           prev, number(op, n, 1));
        break;
      case MS:
        n = jj_consume_token(MS);
          result = LexicalUnitImpl.createMS(n.beginLine, n.beginColumn,
                                            prev, number(op, n, 2));
        break;
      case HZ:
        n = jj_consume_token(HZ);
          result = LexicalUnitImpl.createHZ(n.beginLine, n.beginColumn,
                                            prev, number(op, n, 2));
        break;
      case KHZ:
        n = jj_consume_token(KHZ);
          result = LexicalUnitImpl.createKHZ(n.beginLine, n.beginColumn,
                                             prev, number(op, n, 3));
        break;
      case DIMEN:
        n = jj_consume_token(DIMEN);
            s = n.image;
            int i = 0;
            while (i < s.length()
                   && (Character.isDigit(s.charAt(i)) || (s.charAt(i) == '.'))) {
                i++;
            }
            result = LexicalUnitImpl.createDimen(n.beginLine, n.beginColumn, prev,
                                                 Float.valueOf(s.substring(0, i)).floatValue(),
                                                 s.substring(i));
        break;
      case FUNCTION:
        result = function(op, prev);
        break;
      default:
        jj_la1[214] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case DOT:
    case STRING:
    case IDENT:
    case URL:
    case HASH:
    case UNICODERANGE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        n = jj_consume_token(STRING);
          result =
          LexicalUnitImpl.createString(n.beginLine, n.beginColumn, prev,
                                       convertStringIndex(n.image, 1,
                                                          n.image.length() -1));
        break;
      case DOT:
      case IDENT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          jj_consume_token(DOT);
                   s+=".";
          break;
        default:
          jj_la1[215] = jj_gen;
          ;
        }
        n = jj_consume_token(IDENT);
        s += convertIdent(n.image);
        if ("inherit".equals(s)) {
            result = LexicalUnitImpl.createInherit(n.beginLine, n.beginColumn,
                                               prev);
        } else {
            result = LexicalUnitImpl.createIdent(n.beginLine, n.beginColumn,
                                               prev, convertIdent(n.image));
        }

          /* /
         Auto correction code used in the CSS Validator but must not
          be used by a conformant CSS2 parser.
	 * Common error :
	 * H1 {
	 *   color : black
	 *   background : white
	 * }
	 *
	Token t = getToken(1);
	Token semicolon = new Token();
	semicolon.kind = SEMICOLON;
	semicolon.image = ";";
	if (t.kind == COLON) {
	    // @@SEEME. (generate a warning?)
	    // @@SEEME if expression is a single ident, 
	       generate an error ?
	    rejectToken(semicolon);
	    
	    result = prev;
	}
	/ */

        break;
      case HASH:
        result = hexcolor(prev);
        break;
      case URL:
        result = url(prev);
        break;
      case UNICODERANGE:
        result = unicode(prev);
        break;
      default:
        jj_la1[216] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[217] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_150:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[218] = jj_gen;
        break label_150;
      }
      jj_consume_token(S);
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

/**
 * Handle all CSS2 functions.
 * @exception ParseException exception during the parse
 */
  final public LexicalUnitImpl function(char operator, LexicalUnitImpl prev) throws ParseException {
 Token n;
 LexicalUnit params = null;
    n = jj_consume_token(FUNCTION);
    label_151:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[219] = jj_gen;
        break label_151;
      }
      jj_consume_token(S);
    }
        String fname = convertIdent(n.image);
        if("alpha(".equals(fname)){
            String body = skipStatementUntilSemiColon();
            {if (true) return LexicalUnitImpl.createIdent(n.beginLine, n.beginColumn,
                 null, "alpha("+body);}
        }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
    case DOT:
    case STRING:
    case IDENT:
    case NUMBER:
    case URL:
    case VARIABLE:
    case PERCENTAGE:
    case PT:
    case MM:
    case CM:
    case PC:
    case IN:
    case PX:
    case EMS:
    case EXS:
    case DEG:
    case RAD:
    case GRAD:
    case MS:
    case SECOND:
    case HZ:
    case KHZ:
    case DIMEN:
    case HASH:
    case UNICODERANGE:
    case FUNCTION:
      params = expr();
      break;
    default:
      jj_la1[220] = jj_gen;
      ;
    }
    jj_consume_token(RPARAN);
        if (operator != ' ') {
            {if (true) throw new CSSParseException("invalid operator before a function.",
                                        getLocator());}
        }
        String f = convertIdent(n.image);
        LexicalUnitImpl l = (LexicalUnitImpl) params;
        boolean loop = true;
        if ("rgb(".equals(f)) {
            // this is a RGB declaration (e.g. rgb(255, 50%, 0) )
            int i = 0;
            while (loop && l != null && i < 5) {
                switch (i) {
                    case 0:
                    case 2:
                    case 4:
                        if ((l.getLexicalUnitType() != LexicalUnit.SAC_INTEGER)
                            && (l.getLexicalUnitType() != LexicalUnit.SAC_PERCENTAGE)) {
                            loop = false;
                        }
                        break;
                    case 1:
                    case 3:
                        if (l.getLexicalUnitType() != LexicalUnit.SAC_OPERATOR_COMMA) {
                            loop = false;
                        }
                        break;
                    default:
                        {if (true) throw new ParseException("implementation error");}
                }
                if (loop) {
                    l = (LexicalUnitImpl) l.getNextLexicalUnit();
                    i ++;
                }
            }
            if ((i == 5) && loop && (l == null)) {
                {if (true) return LexicalUnitImpl.createRGBColor(n.beginLine,
                                                      n.beginColumn,
                                                      prev, params);}
            } else {
                if (errorHandler != null) {
                    String errorText;
                    Locator loc;
                    if (i < 5) {
                        if (params == null) {
                            loc = new LocatorImpl(this, n.beginLine,
                                                  n.beginColumn-1);
                            errorText = "not enough parameters.";
                        } else if (l == null) {
                            loc = new LocatorImpl(this, n.beginLine,
                                                  n.beginColumn-1);
                            errorText = "not enough parameters: "
                                + params.toString();
                        } else {
                            loc = new LocatorImpl(this, l.getLineNumber(),
                                                  l.getColumnNumber());
                            errorText = "invalid parameter: "
                                + l.toString();
                        }
                    } else {
                        loc = new LocatorImpl(this, l.getLineNumber(),
                                              l.getColumnNumber());
                        errorText = "too many parameters: "
                            + l.toString();
                    }
                    errorHandler.error(new CSSParseException(errorText, loc));
                }

                {if (true) throw new JumpException();}
            }
        } else if ("counter".equals(f)) {
            int i = 0;
            while (loop && l != null && i < 3) {
                switch (i) {
                    case 0:
                    case 2:
                        if (l.getLexicalUnitType() != LexicalUnit.SAC_IDENT) {
                            loop = false;
                        }
                        break;
                    case 1:
                        if (l.getLexicalUnitType() != LexicalUnit.SAC_OPERATOR_COMMA) {
                            loop = false;
                        }
                        break;
                    default:
                        {if (true) throw new ParseException("implementation error");}
                }
                l = (LexicalUnitImpl) l.getNextLexicalUnit();
                i ++;
            }
            if (((i == 1) || (i == 3)) && loop && (l == null)) {
                {if (true) return LexicalUnitImpl.createCounter(n.beginLine, n.beginColumn,
                                                     prev, params);}
            }

        } else if ("counters(".equals(f)) {

            int i = 0;
            while (loop && l != null && i < 5) {
                switch (i) {
                    case 0:
                    case 4:
                        if (l.getLexicalUnitType() != LexicalUnit.SAC_IDENT) {
                            loop = false;
                        }
                        break;
                    case 2:
                        if (l.getLexicalUnitType() != LexicalUnit.SAC_STRING_VALUE) {
                            loop = false;
                        }
                        break;
                    case 1:
                    case 3:
                        if (l.getLexicalUnitType() != LexicalUnit.SAC_OPERATOR_COMMA) {
                            loop = false;
                        }
                        break;
                    default:
                        {if (true) throw new ParseException("implementation error");}
                }
                l = (LexicalUnitImpl) l.getNextLexicalUnit();
                i ++;
            }
            if (((i == 3) || (i == 5)) && loop && (l == null)) {
                {if (true) return LexicalUnitImpl.createCounters(n.beginLine, n.beginColumn,
                                                      prev, params);}
            }
        } else if ("attr(".equals(f)) {
            if ((l != null)
                && (l.getNextLexicalUnit() == null)
                && (l.getLexicalUnitType() == LexicalUnit.SAC_IDENT)) {
                {if (true) return LexicalUnitImpl.createAttr(l.getLineNumber(),
                                                  l.getColumnNumber(),
                                                  prev, l.getStringValue());}
            }
        } else if ("rect(".equals(f)) {
            int i = 0;
            while (loop && l != null && i < 7) {
                switch (i) {
                    case 0:
                    case 2:
                    case 4:
                    case 6:
                        switch (l.getLexicalUnitType()) {
                        case LexicalUnit.SAC_INTEGER:
                            if (l.getIntegerValue() != 0) {
                                loop = false;
                            }
                            break;
                        case LexicalUnit.SAC_IDENT:
                            if (!l.getStringValue().equals("auto")) {
                                loop = false;
                            }
                            break;
                        case LexicalUnit.SAC_EM:
                        case LexicalUnit.SAC_EX:
                        case LexicalUnit.SAC_PIXEL:
                        case LexicalUnit.SAC_CENTIMETER:
                        case LexicalUnit.SAC_MILLIMETER:
                        case LexicalUnit.SAC_INCH:
                        case LexicalUnit.SAC_POINT:
                        case LexicalUnit.SAC_PICA:
                            // nothing
                            break;
                        default:
                            loop = false;
                        }
                        break;
                    case 1:
                    case 3:
                    case 5:
                        if (l.getLexicalUnitType() != LexicalUnit.SAC_OPERATOR_COMMA) {
                            loop = false;
                        }
                        break;
                    default:
                        {if (true) throw new ParseException("implementation error");}
                }
                l = (LexicalUnitImpl) l.getNextLexicalUnit();
                i ++;
            }
            if ((i == 7) && loop && (l == null)) {
                {if (true) return LexicalUnitImpl.createRect(n.beginLine, n.beginColumn,
                                                  prev, params);}
            }
        }
        {if (true) return LexicalUnitImpl.createFunction(n.beginLine, n.beginColumn, prev,
                                              f.substring(0,
                                                        f.length() -1),
                                              params);}
    throw new Error("Missing return statement in function");
  }

  final public LexicalUnitImpl unicode(LexicalUnitImpl prev) throws ParseException {
  Token n;
    n = jj_consume_token(UNICODERANGE);
     LexicalUnitImpl params = null;
     String s = n.image.substring(2);
     int index = s.indexOf('-');
     if (index == -1) {
         params = LexicalUnitImpl.createInteger(n.beginLine, n.beginColumn,
                                                params, Integer.parseInt(s, 16));
     } else {
         String s1 = s.substring(0, index);
         String s2 = s.substring(index);

         params = LexicalUnitImpl.createInteger(n.beginLine, n.beginColumn,
                                                params, Integer.parseInt(s1, 16));
         params = LexicalUnitImpl.createInteger(n.beginLine, n.beginColumn,
                                                params, Integer.parseInt(s2, 16));
     }

     {if (true) return LexicalUnitImpl.createUnicodeRange(n.beginLine, n.beginColumn,
                                               prev, params);}
    throw new Error("Missing return statement in function");
  }

  final public LexicalUnitImpl url(LexicalUnitImpl prev) throws ParseException {
  Token n;
    n = jj_consume_token(URL);
   String urlname = n.image.substring(4, n.image.length()-1).trim();
   {if (true) return LexicalUnitImpl.createURL(n.beginLine, n.beginColumn, prev, urlname);}
    throw new Error("Missing return statement in function");
  }

/**
 * @exception ParseException exception during the parse
 */
  final public LexicalUnitImpl hexcolor(LexicalUnitImpl prev) throws ParseException {
 Token n;
    n = jj_consume_token(HASH);
     int r;
     LexicalUnitImpl first, params = null;
     String s = n.image.substring(1);

     if(s.length()!=3 && s.length()!=6) {
         first = null;
         {if (true) throw new CSSParseException("invalid hexadecimal notation for RGB: " + s,
                                     getLocator());}
     }
     {if (true) return LexicalUnitImpl.createIdent(n.beginLine, n.beginColumn,
             prev, n.image);}
    throw new Error("Missing return statement in function");
  }

  float number(char operator, Token n, int lengthUnit) throws ParseException {
    String image  = n.image;
    float f = 0;

    if (lengthUnit != 0) {
        image = image.substring(0, image.length() - lengthUnit);
    }
    f = Float.valueOf(image).floatValue();
    return (operator == '-')? -f: f;
  }

  String skipStatementUntilSemiColon() throws ParseException {
    int[] semicolon = {SEMICOLON};
    return skipStatementUntil(semicolon);
  }

  String skipStatementUntilLeftBrace() throws ParseException {
    int[] lBrace = {LBRACE};
    return skipStatementUntil(lBrace);
  }

  String skipStatementUntilRightParan() throws ParseException {
    int[] rParan = {RPARAN};
    return skipStatementUntil(rParan);
  }

  String skipStatementUntil(int[] symbols) throws ParseException {
    StringBuffer s = new StringBuffer();
    boolean stop = false;
    Token tok;
    while(!stop){
        tok = getToken(1);
        if(tok.kind == EOF) {
            return null;
        }
        for(int sym : symbols){
            if(tok.kind == sym){
                stop = true;
                break;
            }
        }
        if(!stop){
            if (tok.image != null) {
                s.append(tok.image);
            }
            getNextToken();
        }
    }
    return s.toString().trim();
  }

  String skipStatement() throws ParseException {
    StringBuffer s = new StringBuffer();
    Token tok = getToken(0);
    if (tok.image != null) {
        s.append(tok.image);
    }
    while (true) {
        tok = getToken(1);
        if (tok.kind == EOF) {
            return null;
        }
        s.append(tok.image);
        if (tok.kind == LBRACE) {
            getNextToken();
            s.append(skip_to_matching_brace());
            getNextToken();
            tok = getToken(1);
            break;
        } else if (tok.kind == RBRACE) {
            getNextToken();
            tok = getToken(1);
            break;
        } else if (tok.kind == SEMICOLON) {
            getNextToken();
            tok = getToken(1);
            break;
        }
        getNextToken();
    }

    // skip white space
    while (true) {
        if (tok.kind != S) {
            break;
        }
        tok = getNextToken();
        tok = getToken(1);
    }

    return s.toString().trim();
  }

  String skip_to_matching_brace() throws ParseException {
    StringBuffer s = new StringBuffer();
    Token tok;
    int nesting = 1;
    while (true) {
        tok = getToken(1);
        if (tok.kind == EOF) {
            break;
        }
        s.append(tok.image);
        if (tok.kind == LBRACE) {
            nesting++;
        } else if (tok.kind == RBRACE) {
            nesting--;
            if (nesting == 0) {
                break;
            }
        }
        getNextToken();
    }
    return s.toString();
  }

  String convertStringIndex(String s, int start, int len) throws ParseException {
    StringBuffer buf = new StringBuffer(len);
    int index = start;

    while (index < len) {
        char c = s.charAt(index);
        if (c == '\u005c\u005c') {
            if (++index < len) {
                c = s.charAt(index);
                switch (c) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
                case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
                    int numValue = Character.digit(c, 16);
                    int count = 0;
                    int p = 16;

                    while (index + 1 < len && count < 6) {
                        c = s.charAt(index+1);

                        if (Character.digit(c, 16) != -1) {
                            numValue = (numValue * 16) + Character.digit(c, 16);
                            p *= 16;
                            index++;
                        } else {
                            if (c == ' ') {
                                // skip the latest white space
                                index++;
                            }
                            break;
                        }
                    }
                    buf.append((char) numValue);
                    break;
                case '\u005cn':
                case '\u005cf':
                    break;
                case '\u005cr':
                    if (index + 1 < len) {
                        if (s.charAt(index + 1) == '\u005cn') {
                            index ++;
                        }
                    }
                    break;
                default:
                    buf.append(c);
                }
            } else {
                throw new CSSParseException("invalid string " + s, getLocator());
            }
        } else {
            buf.append(c);
        }
        index++;
    }

    return buf.toString();
  }

  String convertIdent(String s) throws ParseException {
    return convertStringIndex(s, 0, s.length());
  }

  String convertString(String s) throws ParseException {
    return convertStringIndex(s, 0, s.length());
  }

  void comments() throws ParseException {
    if (token.specialToken != null){
        Token tmp_t = token.specialToken;
        while (tmp_t.specialToken != null) tmp_t = tmp_t.specialToken;
        while (tmp_t != null) {
            documentHandler.comment(tmp_t.image);
            tmp_t = tmp_t.next;
        }
    }
  }

  void rejectToken(Token t) throws ParseException {
    Token fakeToken = new Token();
    t.next = token;
    fakeToken.next = t;
    token = fakeToken;
  }

  String skipAfterExpression() throws ParseException {
    Token t = getToken(1);
    StringBuffer s = new StringBuffer();
    s.append(getToken(0).image);

    while ((t.kind != RBRACE) && (t.kind != SEMICOLON) && (t.kind != EOF)) {
        s.append(t.image);
        getNextToken();
        t = getToken(1);
    }

    return s.toString();
  }

/**
 * The following functions are useful for a DOM CSS implementation only and are
 * not part of the general CSS2 parser.
 */
  final public void _parseRule() throws ParseException {
 String ret = null;
    label_152:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[221] = jj_gen;
        break label_152;
      }
      jj_consume_token(S);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPORT_SYM:
      importDeclaration();
      break;
    case DEBUG_SYM:
    case WARN_SYM:
      debuggingDirective();
      break;
    case LBRACKET:
    case ANY:
    case PARENT:
    case DOT:
    case COLON:
    case INTERPOLATION:
    case IDENT:
    case HASH:
      styleRule();
      break;
    case MEDIA_SYM:
      media();
      break;
    case PAGE_SYM:
      page();
      break;
    case FONT_FACE_SYM:
      fontFace();
      break;
    default:
      jj_la1[222] = jj_gen;
      ret = skipStatement();
                    if ((ret == null) || (ret.length() == 0)) {
                        {if (true) return;}
                    }
                    if (ret.charAt(0) == '@') {
                        documentHandler.unrecognizedRule(ret);
                    } else {
                        {if (true) throw new CSSParseException("unrecognize rule: " + ret,
                                                    getLocator());}
                    }
    }
  }

  final public void _parseImportRule() throws ParseException {
    label_153:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[223] = jj_gen;
        break label_153;
      }
      jj_consume_token(S);
    }
    importDeclaration();
  }

  final public void _parseMediaRule() throws ParseException {
    label_154:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[224] = jj_gen;
        break label_154;
      }
      jj_consume_token(S);
    }
    media();
  }

  final public void _parseDeclarationBlock() throws ParseException {
    label_155:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S:
        ;
        break;
      default:
        jj_la1[225] = jj_gen;
        break label_155;
      }
      jj_consume_token(S);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERPOLATION:
    case IDENT:
      declaration();
      break;
    default:
      jj_la1[226] = jj_gen;
      ;
    }
    label_156:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        ;
        break;
      default:
        jj_la1[227] = jj_gen;
        break label_156;
      }
      jj_consume_token(SEMICOLON);
      label_157:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[228] = jj_gen;
          break label_157;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTERPOLATION:
      case IDENT:
        declaration();
        break;
      default:
        jj_la1[229] = jj_gen;
        ;
      }
    }
  }

  final public ArrayList<String> _parseSelectors() throws ParseException {
  ArrayList<String> p = null;
    try {
      label_158:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[230] = jj_gen;
          break label_158;
        }
        jj_consume_token(S);
      }
      p = selectorList();
          {if (true) return p;}
    } catch (ThrowedParseException e) {
        {if (true) throw (ParseException) e.e.fillInStackTrace();}
    }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_3_5() {
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_196() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) {
    jj_scanpos = xsp;
    if (jj_3R_247()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_159()) return true;
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_3R_261()) return true;
    return false;
  }

  private boolean jj_3R_276() {
    if (jj_3R_243()) return true;
    return false;
  }

  private boolean jj_3R_175() {
    if (jj_3R_196()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_161()) return true;
    if (jj_3R_162()) return true;
    return false;
  }

  private boolean jj_3R_255() {
    if (jj_scan_token(FUNCTION)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_276()) jj_scanpos = xsp;
    if (jj_scan_token(RPARAN)) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_228()) return true;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_3R_162()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_3()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_174() {
    if (jj_3R_195()) return true;
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_3R_260()) return true;
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_3R_259()) return true;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_3R_258()) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_3R_257()) return true;
    return false;
  }

  private boolean jj_3R_296() {
    if (jj_scan_token(EACH_SYM)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(VARIABLE)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(EACH_IN)) return true;
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_3R_228()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_229()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_241() {
    if (jj_scan_token(SEMICOLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_173() {
    if (jj_3R_194()) return true;
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_scan_token(EXTEND_SYM)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_187()) return true;
    if (jj_3R_241()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_241()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_172() {
    if (jj_3R_193()) return true;
    return false;
  }

  private boolean jj_3R_188() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_256() {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_224() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_256()) jj_scanpos = xsp;
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_309() {
    if (jj_scan_token(INTERPOLATION)) return true;
    return false;
  }

  private boolean jj_3R_354() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_3R_255()) return true;
    return false;
  }

  private boolean jj_3R_186() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) {
    jj_scanpos = xsp;
    if (jj_3R_225()) {
    jj_scanpos = xsp;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_3R_187()) return true;
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_188()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_3R_192()) return true;
    return false;
  }

  private boolean jj_3R_263() {
    if (jj_scan_token(FUNCTION)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_scan_token(DIMEN)) return true;
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_scan_token(KHZ)) return true;
    return false;
  }

  private boolean jj_3R_242() {
    if (jj_scan_token(VARIABLE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_scan_token(HZ)) return true;
    return false;
  }

  private boolean jj_3R_245() {
    if (jj_scan_token(SEMICOLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_312() {
    if (jj_scan_token(WARN_SYM)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_scan_token(MS)) return true;
    return false;
  }

  private boolean jj_3R_285() {
    if (jj_3R_312()) return true;
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_scan_token(SECOND)) return true;
    return false;
  }

  private boolean jj_3R_308() {
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_280() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_308()) {
    jj_scanpos = xsp;
    if (jj_3R_309()) return true;
    }
    return false;
  }

  private boolean jj_3R_262() {
    Token xsp;
    if (jj_3R_280()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_280()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_scan_token(GRAD)) return true;
    return false;
  }

  private boolean jj_3R_340() {
    if (jj_3R_354()) return true;
    return false;
  }

  private boolean jj_3R_278() {
    if (jj_3R_296()) return true;
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_scan_token(RAD)) return true;
    return false;
  }

  private boolean jj_3R_295() {
    if (jj_scan_token(IF_SYM)) return true;
    Token xsp;
    if (jj_3R_340()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_340()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  private boolean jj_3R_311() {
    if (jj_scan_token(DEBUG_SYM)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_scan_token(DEG)) return true;
    return false;
  }

  private boolean jj_3R_307() {
    if (jj_scan_token(S)) return true;
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_scan_token(EXS)) return true;
    return false;
  }

  private boolean jj_3R_306() {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_305() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_304() {
    if (jj_scan_token(RPARAN)) return true;
    return false;
  }

  private boolean jj_3R_212() {
    if (jj_scan_token(EMS)) return true;
    return false;
  }

  private boolean jj_3R_303() {
    if (jj_scan_token(FUNCTION)) return true;
    return false;
  }

  private boolean jj_3R_160() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_3R_172()) {
    jj_scanpos = xsp;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_159()) return true;
    return false;
  }

  private boolean jj_3R_302() {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_244() {
    if (jj_3R_270()) return true;
    return false;
  }

  private boolean jj_3R_271() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_284()) {
    jj_scanpos = xsp;
    if (jj_3R_285()) return true;
    }
    return false;
  }

  private boolean jj_3R_284() {
    if (jj_3R_311()) return true;
    return false;
  }

  private boolean jj_3R_301() {
    if (jj_scan_token(INTERPOLATION)) return true;
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_scan_token(PX)) return true;
    return false;
  }

  private boolean jj_3R_300() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_299() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_298() {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  private boolean jj_3R_260() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_277()) {
    jj_scanpos = xsp;
    if (jj_3R_278()) return true;
    }
    return false;
  }

  private boolean jj_3R_277() {
    if (jj_3R_295()) return true;
    return false;
  }

  private boolean jj_3R_297() {
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_279() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_297()) {
    jj_scanpos = xsp;
    if (jj_3R_298()) {
    jj_scanpos = xsp;
    if (jj_3R_299()) {
    jj_scanpos = xsp;
    if (jj_3R_300()) {
    jj_scanpos = xsp;
    if (jj_3R_301()) {
    jj_scanpos = xsp;
    if (jj_3R_302()) {
    jj_scanpos = xsp;
    if (jj_3R_303()) {
    jj_scanpos = xsp;
    if (jj_3R_304()) {
    jj_scanpos = xsp;
    if (jj_3R_305()) {
    jj_scanpos = xsp;
    if (jj_3R_306()) {
    jj_scanpos = xsp;
    if (jj_3R_307()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_209() {
    if (jj_scan_token(PC)) return true;
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_scan_token(MM)) return true;
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_scan_token(CM)) return true;
    return false;
  }

  private boolean jj_3R_261() {
    if (jj_scan_token(MICROSOFT_RULE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_279()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_279()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_scan_token(PT)) return true;
    return false;
  }

  private boolean jj_3R_250() {
    if (jj_scan_token(SIBLING)) return true;
    return false;
  }

  private boolean jj_3R_249() {
    if (jj_scan_token(PRECEDES)) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(PERCENTAGE)) return true;
    return false;
  }

  private boolean jj_3R_248() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_3R_234()) return true;
    return false;
  }

  private boolean jj_3R_204() {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_197() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) {
    jj_scanpos = xsp;
    if (jj_3R_250()) return true;
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_3R_254()) return true;
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_scan_token(SIBLING)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_177() {
    if (jj_scan_token(PRECEDES)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_185() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) {
    jj_scanpos = xsp;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_179() {
    if (jj_scan_token(S)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_197()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_164() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_161() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_176() {
    if (jj_scan_token(PLUS)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_3R_242()) return true;
    if (jj_scan_token(COLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_243()) return true;
    xsp = jj_scanpos;
    if (jj_3R_244()) jj_scanpos = xsp;
    if (jj_3R_245()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_245()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_257() {
    if (jj_scan_token(HASH)) return true;
    return false;
  }

  private boolean jj_3R_234() {
    if (jj_3R_242()) return true;
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_3R_164()) return true;
    return false;
  }

  private boolean jj_3R_170() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) return true;
    }
    return false;
  }

  private boolean jj_3R_258() {
    if (jj_scan_token(URL)) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_3R_189()) return true;
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_scan_token(HASH)) return true;
    return false;
  }

  private boolean jj_3R_329() {
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_275() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_254() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) return true;
    }
    return false;
  }

  private boolean jj_3R_274() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_330() {
    if (jj_scan_token(FUNCTION)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_169()) jj_scanpos = xsp;
    if (jj_3R_170()) return true;
    return false;
  }

  private boolean jj_3R_243() {
    if (jj_3R_170()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_11()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_283() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(76)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_259() {
    if (jj_scan_token(UNICODERANGE)) return true;
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_328() {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_scan_token(VARIABLE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(COLON)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CONTAINS)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_189() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) return true;
    }
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_scan_token(DIV)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_scan_token(COLON)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_328()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_329()) {
    jj_scanpos = xsp;
    if (jj_3R_330()) return true;
    }
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_167()) return true;
    return false;
  }

  private boolean jj_3R_270() {
    if (jj_scan_token(GUARDED_SYM)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_341() {
    if (jj_scan_token(IMPORTANT_SYM)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_scan_token(VARIABLE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(COLON)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(REMOVE)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_166()) return true;
    return false;
  }

  private boolean jj_3R_238() {
    if (jj_scan_token(SEMICOLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_310() {
    if (jj_scan_token(COLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_281() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_310()) jj_scanpos = xsp;
    if (jj_3R_170()) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_scan_token(VARIABLE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(COLON)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(APPEND)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_269() {
    if (jj_3R_283()) return true;
    return false;
  }

  private boolean jj_3R_353() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_351() {
    if (jj_scan_token(STARMATCH)) return true;
    return false;
  }

  private boolean jj_3R_352() {
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_350() {
    if (jj_scan_token(DOLLARMATCH)) return true;
    return false;
  }

  private boolean jj_3R_349() {
    if (jj_scan_token(CARETMATCH)) return true;
    return false;
  }

  private boolean jj_3R_348() {
    if (jj_scan_token(DASHMATCH)) return true;
    return false;
  }

  private boolean jj_3R_347() {
    if (jj_scan_token(INCLUDES)) return true;
    return false;
  }

  private boolean jj_3R_289() {
    if (jj_scan_token(INTERPOLATION)) return true;
    return false;
  }

  private boolean jj_3R_346() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_335() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_346()) {
    jj_scanpos = xsp;
    if (jj_3R_347()) {
    jj_scanpos = xsp;
    if (jj_3R_348()) {
    jj_scanpos = xsp;
    if (jj_3R_349()) {
    jj_scanpos = xsp;
    if (jj_3R_350()) {
    jj_scanpos = xsp;
    if (jj_3R_351()) return true;
    }
    }
    }
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_352()) {
    jj_scanpos = xsp;
    if (jj_3R_353()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_342() {
    if (jj_3R_262()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_268() {
    if (jj_3R_168()) return true;
    return false;
  }

  private boolean jj_3R_236() {
    if (jj_3R_242()) return true;
    return false;
  }

  private boolean jj_3R_159() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3_9()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_165()) return true;
    return false;
  }

  private boolean jj_3R_202() {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(IDENT)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_335()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_343() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_345() {
    if (jj_scan_token(INTERPOLATION)) return true;
    return false;
  }

  private boolean jj_3R_266() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_265()) return true;
    return false;
  }

  private boolean jj_3R_237() {
    if (jj_3R_263()) return true;
    if (jj_3R_264()) return true;
    if (jj_scan_token(RPARAN)) return true;
    return false;
  }

  private boolean jj_3R_253() {
    if (jj_scan_token(PARENT)) return true;
    return false;
  }

  private boolean jj_3R_265() {
    if (jj_scan_token(IDENT)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_252() {
    if (jj_scan_token(ANY)) return true;
    return false;
  }

  private boolean jj_3R_235() {
    if (jj_3R_262()) return true;
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_scan_token(INCLUDE_SYM)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) return true;
    }
    }
    if (jj_3R_238()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_238()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_240() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_267()) {
    jj_scanpos = xsp;
    if (jj_3R_268()) {
    jj_scanpos = xsp;
    if (jj_3R_269()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_267() {
    if (jj_3R_271()) return true;
    return false;
  }

  private boolean jj_3R_273() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_288()) {
    jj_scanpos = xsp;
    if (jj_3R_289()) return true;
    }
    return false;
  }

  private boolean jj_3R_288() {
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_315() {
    if (jj_scan_token(SEMICOLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_343()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_198() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_251() {
    Token xsp;
    if (jj_3R_273()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_273()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_239() {
    if (jj_3R_265()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_266()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_282() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_170()) return true;
    return false;
  }

  private boolean jj_3R_339() {
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_264() {
    if (jj_3R_170()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_281()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_282()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_344() {
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_323() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_344()) {
    jj_scanpos = xsp;
    if (jj_3R_345()) return true;
    }
    return false;
  }

  private boolean jj_3R_337() {
    if (jj_3R_200()) return true;
    return false;
  }

  private boolean jj_3R_334() {
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_332() {
    if (jj_3R_200()) return true;
    return false;
  }

  private boolean jj_3R_322() {
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_314() {
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    if (jj_3R_323()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_323()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_327() {
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_325() {
    if (jj_3R_200()) return true;
    return false;
  }

  private boolean jj_3R_287() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_314()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_315()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_scan_token(MEDIA_SYM)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_239()) return true;
    if (jj_scan_token(LBRACE)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_240()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_6() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_163()) jj_scanpos = xsp;
    if (jj_3R_164()) return true;
    return false;
  }

  private boolean jj_3R_313() {
    if (jj_3R_341()) return true;
    return false;
  }

  private boolean jj_3R_247() {
    if (jj_3R_272()) return true;
    return false;
  }

  private boolean jj_3R_338() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_336() {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_294() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_336()) {
    jj_scanpos = xsp;
    if (jj_3R_337()) {
    jj_scanpos = xsp;
    if (jj_3R_338()) {
    jj_scanpos = xsp;
    if (jj_3R_339()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_331() {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_293() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_331()) {
    jj_scanpos = xsp;
    if (jj_3R_332()) {
    jj_scanpos = xsp;
    if (jj_3R_333()) {
    jj_scanpos = xsp;
    if (jj_3R_334()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_319() {
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_333() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_324() {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_292() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_324()) {
    jj_scanpos = xsp;
    if (jj_3R_325()) {
    jj_scanpos = xsp;
    if (jj_3R_326()) {
    jj_scanpos = xsp;
    if (jj_3R_327()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_321() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_286() {
    if (jj_3R_243()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_313()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_326() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_320() {
    if (jj_3R_200()) return true;
    return false;
  }

  private boolean jj_3R_317() {
    if (jj_3R_200()) return true;
    return false;
  }

  private boolean jj_3R_291() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_320()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) {
    jj_scanpos = xsp;
    if (jj_3R_322()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_272() {
    if (jj_3R_262()) return true;
    if (jj_scan_token(COLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_286()) {
    jj_scanpos = xsp;
    if (jj_3R_287()) return true;
    }
    return false;
  }

  private boolean jj_3R_246() {
    if (jj_3R_271()) return true;
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_3R_202()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_294()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_3R_201()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_293()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_318() {
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_3R_200()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_292()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_316() {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_181() {
    if (jj_3R_199()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_291()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_290() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_316()) {
    jj_scanpos = xsp;
    if (jj_3R_317()) {
    jj_scanpos = xsp;
    if (jj_3R_318()) {
    jj_scanpos = xsp;
    if (jj_3R_319()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_3R_198()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_290()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_162() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_10() {
    if (jj_3R_168()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[231];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0xc02,0xc02,0x0,0xc00,0x2,0x2,0x2,0xd0000000,0xc00,0x2,0xc00,0x2,0x0,0x2,0x0,0x2,0x2,0x2,0xd3f45400,0xd3f45400,0x2,0x400000,0x2,0x2,0x2,0x2,0x0,0x0,0x2,0x0,0x800000,0x2,0x0,0x2,0x2,0x2,0x2,0x0,0x800000,0x2,0x0,0x2,0x3f45400,0x2,0x2,0x2,0x3100000,0x2,0x3100000,0x3100002,0x2,0x480002,0x480002,0x2,0x0,0x0,0x2,0x2,0x2,0x2,0xd0000000,0x0,0x2,0x400000,0x2,0x2,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0xd0000000,0x0,0x0,0x0,0x0,0xc0000000,0x2,0x2,0xfc000,0x2,0x0,0x2,0xfc000,0x0,0x2,0x0,0x2,0x0,0x2,0x800000,0x0,0xd0000000,0x4d380002,0x2,0xd0000000,0x2,0x0,0x2,0x4d380002,0x0,0x2,0xd0000000,0x2,0x4d380002,0x2,0x2,0x2,0x0,0x2,0xd0000000,0x2,0x2,0x400000,0x2,0x2,0x2,0x2,0x0,0x2,0xd0000000,0x0,0x2,0x400000,0x2,0x2,0x2,0x400000,0x0,0x0,0x300000,0x2,0x0,0x400000,0x2,0x300000,0x2,0x0,0x2,0x0,0x2,0x800000,0x2,0x2,0x2,0x0,0x2,0x2,0x2,0x400000,0x2,0x2,0x2,0x2,0x2,0x0,0x2,0x2,0x2,0x400000,0x2,0x2,0x2,0x2,0x2,0x0,0x2,0x2,0x2,0x400000,0x2,0x2,0x0,0x2,0x2,0x0,0x2,0x2,0x2,0x800000,0x2,0x2,0x0,0x800000,0x2,0x0,0x2,0x0,0x2,0x0,0x2,0x0,0x800000,0x2,0x0,0x2,0x301000,0x2,0x0,0x2,0x2,0x2,0x2,0x8400000,0x8400000,0x300000,0x300000,0x300000,0x0,0x0,0x0,0x300000,0x2,0x2,0x300000,0x2,0xd0000000,0x2,0x2,0x2,0x0,0x800000,0x2,0x0,0x2,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x56600181,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000381,0x6000381,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x100,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x100,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x185,0x185,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x56400181,0x50000000,0x0,0x0,0x0,0x0,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x181,0x100,0x100,0x100,0x100,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x50000000,0x6400181,0x7e,0x0,0x6400181,0x0,0x80000000,0x0,0x7e,0x0,0x0,0x6400181,0x0,0x7e,0x0,0x0,0x0,0x0,0x0,0x6400181,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x56400181,0x50000000,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x81,0x0,0x80,0x0,0x0,0x81,0x0,0x80,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x6000000,0x0,0x0,0xc0000,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x100,0x0,0x6000100,0x0,0x0,0x0,0x100,0x0,0x0,0x100,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x1,0x1,0x1,0x0,0x0,0x1,0x0,0x6000181,0x0,0x0,0x0,0x100,0x0,0x0,0x100,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0xa0000880,0x0,0x0,0x0,0x0,0x440,0x0,0x80,0x0,0x0,0x0,0xe00015c0,0xe00015c0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x80,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x80,0x0,0xc0001540,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x1c0,0x0,0x80,0x80,0x0,0x0,0x0,0x0,0xa0000889,0x8,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x20000000,0x20000000,0x20000000,0x20000000,0x20000000,0x20000000,0x20000080,0x80,0x80,0x80,0x80,0x80,0x0,0x0,0x0,0x0,0xc0,0x0,0x0,0x0,0x0,0x80,0x0,0x20,0x0,0x0,0x0,0xa0000881,0x980,0x0,0xa0000881,0x0,0x0,0x0,0x980,0x10,0x0,0xa0000881,0x0,0x980,0x0,0x0,0x0,0x880,0x0,0xa0000881,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0xa0000881,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x800,0x3ffffdc0,0x0,0x0,0x0,0x0,0x3ffffdc0,0x0,0x0,0x0,0x880,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0x80,0x0,0x0,0x80,0x0,0x3ffffdc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffffdc0,0x0,0x1ffff100,0x0,0x200004c0,0x3ffff5c0,0x0,0x0,0x3ffffdc0,0x0,0xe0000080,0x0,0x0,0x0,0x80,0x0,0x0,0x80,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x1,0x8,0x8,0x0,0x8,0x0,0x0,0x0,0x6,0x8,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc401f,0xc401f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc401f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x6,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x44000,0x0,0x0,0x0,0x0,0x44000,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x44000,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x44000,0x0,0x40000,0x0,0x4000,0x44000,0x0,0x0,0x44000,0x0,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[11];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with user supplied CharStream. */
  public Parser(CharStream stream) {
    token_source = new ParserTokenManager(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 231; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(CharStream stream) {
    token_source.ReInit(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 231; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 231; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 231; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[116];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 231; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 116; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 11; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
