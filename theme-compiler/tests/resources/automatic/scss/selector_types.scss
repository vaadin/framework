* {
	type: universal;
}

attrib .attrib {
	type: attribute;
}

.attrib[foo] .attrib[foo="bar"] .attrib[foo~="bar"] .attrib[foo^="bar"] .attrib[foo$="bar"] .attrib[foo*="bar"] .attrib[foo|="bar"] {
	type: attribute;
}

.pseudo:root .pseudo:first-child {
	type: pseudo-class;
}

.pseudo:root .pseudo:first-child {
	type: pseudo-class;
}

.pseudo:nth-child(3) {
	type: pseudo-class;
}

.pseudo:nth-child(10n-1) {
	type: pseudo-class;
}

.pseudo:nth-child(odd), .pseudo:nth-child(even) {
	type: pseudo-class;
}

.pseudo:nth-child(2n+1), .pseudo:nth-child(4n+3), .pseudo:nth-child(0n+5), .pseudo:nth-child(n) {
	type: pseudo-class;
}

// whitespace
.pseudo:nth-child( +3n - 2 ), .pseudo:nth-child( -n+ 6), .pseudo:nth-child( +6 ) {
	type: pseudo-class;
}

.pseudo:lang(fr) {
	type: pseudo-class;
}

.pseudo:not(s) .pseudo:not(.s) {
	type: pseudo-class;
}

.pseudo::after {
	type: pseudo-element;
}

.pseudo[foo="bar"]::after {
	type: pseudo-combined;
}

.foo.warning {
	type: class;
}

.id#myid {
	type: id;
}

E F {
	type: descendant;
}

E > F {
	type: child;
}

E + F {
	type: adjacent;
}

E ~ F {
	type: sibling;
}
